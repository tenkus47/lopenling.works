"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkteminusclient"] = self["webpackChunkteminusclient"] || []).push([["defaultVendors-node_modules_react-zoom-pan-pinch_dist_index_esm_js"],{

/***/ "./node_modules/react-zoom-pan-pinch/dist/index.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-zoom-pan-pinch/dist/index.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TransformComponent\": () => (/* binding */ TransformComponent),\n/* harmony export */   \"TransformWrapper\": () => (/* binding */ TransformWrapper),\n/* harmony export */   \"useTransformContext\": () => (/* binding */ useTransformContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\n\n/**\n * Rounds number to given decimal\n * eg. roundNumber(2.34343, 1) => 2.3\n */\nvar roundNumber = function (num, decimal) {\n    return Number(num.toFixed(decimal));\n};\n/**\n * Checks if value is number, if not it returns default value\n * 1# eg. checkIsNumber(2, 30) => 2\n * 2# eg. checkIsNumber(null, 30) => 30\n */\nvar checkIsNumber = function (num, defaultValue) {\n    return typeof num === \"number\" ? num : defaultValue;\n};\n\nvar handleCallback = function (context, event, callback) {\n    if (callback && typeof callback === \"function\") {\n        callback(context, event);\n    }\n};\n\n/**\n * Functions should return denominator of the target value, which is the next animation step.\n * t is a value from 0 to 1, reflecting the percentage of animation status.\n */\nvar easeOut = function (t) {\n    return -Math.cos(t * Math.PI) / 2 + 0.5;\n};\n// linear\nvar linear = function (t) {\n    return t;\n};\n// accelerating from zero velocity\nvar easeInQuad = function (t) {\n    return t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuad = function (t) {\n    return t * (2 - t);\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuad = function (t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n};\n// accelerating from zero velocity\nvar easeInCubic = function (t) {\n    return t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutCubic = function (t) {\n    return --t * t * t + 1;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutCubic = function (t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n};\n// accelerating from zero velocity\nvar easeInQuart = function (t) {\n    return t * t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuart = function (t) {\n    return 1 - --t * t * t * t;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuart = function (t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n};\n// accelerating from zero velocity\nvar easeInQuint = function (t) {\n    return t * t * t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuint = function (t) {\n    return 1 + --t * t * t * t * t;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuint = function (t) {\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n};\nvar animations = {\n    easeOut: easeOut,\n    linear: linear,\n    easeInQuad: easeInQuad,\n    easeOutQuad: easeOutQuad,\n    easeInOutQuad: easeInOutQuad,\n    easeInCubic: easeInCubic,\n    easeOutCubic: easeOutCubic,\n    easeInOutCubic: easeInOutCubic,\n    easeInQuart: easeInQuart,\n    easeOutQuart: easeOutQuart,\n    easeInOutQuart: easeInOutQuart,\n    easeInQuint: easeInQuint,\n    easeOutQuint: easeOutQuint,\n    easeInOutQuint: easeInOutQuint,\n};\n\nvar handleCancelAnimationFrame = function (animation) {\n    if (typeof animation === \"number\") {\n        cancelAnimationFrame(animation);\n    }\n};\nvar handleCancelAnimation = function (contextInstance) {\n    if (!contextInstance.mounted)\n        return;\n    handleCancelAnimationFrame(contextInstance.animation);\n    // Clear animation state\n    contextInstance.animate = false;\n    contextInstance.animation = null;\n    contextInstance.velocity = null;\n};\nfunction handleSetupAnimation(contextInstance, animationName, animationTime, callback) {\n    if (!contextInstance.mounted)\n        return;\n    var startTime = new Date().getTime();\n    var lastStep = 1;\n    // if another animation is active\n    handleCancelAnimation(contextInstance);\n    // new animation\n    contextInstance.animation = function () {\n        if (!contextInstance.mounted) {\n            return handleCancelAnimationFrame(contextInstance.animation);\n        }\n        var frameTime = new Date().getTime() - startTime;\n        var animationProgress = frameTime / animationTime;\n        var animationType = animations[animationName];\n        var step = animationType(animationProgress);\n        if (frameTime >= animationTime) {\n            callback(lastStep);\n            contextInstance.animation = null;\n        }\n        else if (contextInstance.animation) {\n            callback(step);\n            requestAnimationFrame(contextInstance.animation);\n        }\n    };\n    requestAnimationFrame(contextInstance.animation);\n}\nfunction animate(contextInstance, targetState, animationTime, animationName) {\n    var isValid = isValidTargetState(targetState);\n    if (!contextInstance.mounted || !isValid)\n        return;\n    var setTransformState = contextInstance.setTransformState;\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    var scaleDiff = targetState.scale - scale;\n    var positionXDiff = targetState.positionX - positionX;\n    var positionYDiff = targetState.positionY - positionY;\n    if (animationTime === 0) {\n        setTransformState(targetState.scale, targetState.positionX, targetState.positionY);\n    }\n    else {\n        // animation start timestamp\n        handleSetupAnimation(contextInstance, animationName, animationTime, function (step) {\n            var newScale = scale + scaleDiff * step;\n            var newPositionX = positionX + positionXDiff * step;\n            var newPositionY = positionY + positionYDiff * step;\n            setTransformState(newScale, newPositionX, newPositionY);\n        });\n    }\n}\nfunction isValidTargetState(targetState) {\n    var scale = targetState.scale, positionX = targetState.positionX, positionY = targetState.positionY;\n    if (isNaN(scale) || isNaN(positionX) || isNaN(positionY)) {\n        return false;\n    }\n    return true;\n}\n\nfunction getComponentsSizes(wrapperComponent, contentComponent, newScale) {\n    var wrapperWidth = wrapperComponent.offsetWidth;\n    var wrapperHeight = wrapperComponent.offsetHeight;\n    var contentWidth = contentComponent.offsetWidth;\n    var contentHeight = contentComponent.offsetHeight;\n    var newContentWidth = contentWidth * newScale;\n    var newContentHeight = contentHeight * newScale;\n    var newDiffWidth = wrapperWidth - newContentWidth;\n    var newDiffHeight = wrapperHeight - newContentHeight;\n    return {\n        wrapperWidth: wrapperWidth,\n        wrapperHeight: wrapperHeight,\n        newContentWidth: newContentWidth,\n        newDiffWidth: newDiffWidth,\n        newContentHeight: newContentHeight,\n        newDiffHeight: newDiffHeight,\n    };\n}\nvar getBounds = function (wrapperWidth, newContentWidth, diffWidth, wrapperHeight, newContentHeight, diffHeight, centerZoomedOut) {\n    var scaleWidthFactor = wrapperWidth > newContentWidth\n        ? diffWidth * (centerZoomedOut ? 1 : 0.5)\n        : 0;\n    var scaleHeightFactor = wrapperHeight > newContentHeight\n        ? diffHeight * (centerZoomedOut ? 1 : 0.5)\n        : 0;\n    var minPositionX = wrapperWidth - newContentWidth - scaleWidthFactor;\n    var maxPositionX = scaleWidthFactor;\n    var minPositionY = wrapperHeight - newContentHeight - scaleHeightFactor;\n    var maxPositionY = scaleHeightFactor;\n    return { minPositionX: minPositionX, maxPositionX: maxPositionX, minPositionY: minPositionY, maxPositionY: maxPositionY };\n};\nvar calculateBounds = function (contextInstance, newScale) {\n    var wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n    var centerZoomedOut = contextInstance.setup.centerZoomedOut;\n    if (!wrapperComponent || !contentComponent) {\n        throw new Error(\"Components are not mounted\");\n    }\n    var _a = getComponentsSizes(wrapperComponent, contentComponent, newScale), wrapperWidth = _a.wrapperWidth, wrapperHeight = _a.wrapperHeight, newContentWidth = _a.newContentWidth, newDiffWidth = _a.newDiffWidth, newContentHeight = _a.newContentHeight, newDiffHeight = _a.newDiffHeight;\n    var bounds = getBounds(wrapperWidth, newContentWidth, newDiffWidth, wrapperHeight, newContentHeight, newDiffHeight, Boolean(centerZoomedOut));\n    return bounds;\n};\nvar handleCalculateBounds = function (contextInstance, newScale) {\n    var bounds = calculateBounds(contextInstance, newScale);\n    // Save bounds\n    contextInstance.bounds = bounds;\n    return bounds;\n};\nfunction getMouseBoundedPosition(positionX, positionY, bounds, limitToBounds, paddingValueX, paddingValueY, wrapperComponent) {\n    var minPositionX = bounds.minPositionX, minPositionY = bounds.minPositionY, maxPositionX = bounds.maxPositionX, maxPositionY = bounds.maxPositionY;\n    var paddingX = 0;\n    var paddingY = 0;\n    if (wrapperComponent) {\n        paddingX = paddingValueX;\n        paddingY = paddingValueY;\n    }\n    var x = boundLimiter(positionX, minPositionX - paddingX, maxPositionX + paddingX, limitToBounds);\n    var y = boundLimiter(positionY, minPositionY - paddingY, maxPositionY + paddingY, limitToBounds);\n    return { x: x, y: y };\n}\n/**\n * Keeps value between given bounds, used for limiting view to given boundaries\n * 1# eg. boundLimiter(2, 0, 3, true) => 2\n * 2# eg. boundLimiter(4, 0, 3, true) => 3\n * 3# eg. boundLimiter(-2, 0, 3, true) => 0\n * 4# eg. boundLimiter(10, 0, 3, false) => 10\n */\nvar boundLimiter = function (value, minBound, maxBound, isActive) {\n    if (!isActive)\n        return roundNumber(value, 2);\n    if (value < minBound)\n        return roundNumber(minBound, 2);\n    if (value > maxBound)\n        return roundNumber(maxBound, 2);\n    return roundNumber(value, 2);\n};\n\nfunction handleCalculateZoomPositions(contextInstance, mouseX, mouseY, newScale, bounds, limitToBounds) {\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    var scaleDifference = newScale - scale;\n    if (typeof mouseX !== \"number\" || typeof mouseY !== \"number\") {\n        console.error(\"Mouse X and Y position were not provided!\");\n        return { x: positionX, y: positionY };\n    }\n    var calculatedPositionX = positionX - mouseX * scaleDifference;\n    var calculatedPositionY = positionY - mouseY * scaleDifference;\n    // do not limit to bounds when there is padding animation,\n    // it causes animation strange behaviour\n    var newPositions = getMouseBoundedPosition(calculatedPositionX, calculatedPositionY, bounds, limitToBounds, 0, 0, null);\n    return newPositions;\n}\nfunction checkZoomBounds(zoom, minScale, maxScale, zoomPadding, enablePadding) {\n    var scalePadding = enablePadding ? zoomPadding : 0;\n    var minScaleWithPadding = minScale - scalePadding;\n    if (!isNaN(maxScale) && zoom >= maxScale)\n        return maxScale;\n    if (!isNaN(minScale) && zoom <= minScaleWithPadding)\n        return minScaleWithPadding;\n    return zoom;\n}\n\nvar isPanningStartAllowed = function (contextInstance, event) {\n    var excluded = contextInstance.setup.panning.excluded;\n    var isInitialized = contextInstance.isInitialized, wrapperComponent = contextInstance.wrapperComponent;\n    var target = event.target;\n    var isWrapperChild = wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.contains(target);\n    var isAllowed = isInitialized && target && isWrapperChild;\n    if (!isAllowed)\n        return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded)\n        return false;\n    return true;\n};\nvar isPanningAllowed = function (contextInstance) {\n    var isInitialized = contextInstance.isInitialized, isPanning = contextInstance.isPanning, setup = contextInstance.setup;\n    var disabled = setup.panning.disabled;\n    var isAllowed = isInitialized && isPanning && !disabled;\n    if (!isAllowed)\n        return false;\n    return true;\n};\nvar handlePanningSetup = function (contextInstance, event) {\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY;\n    contextInstance.isPanning = true;\n    // Panning with mouse\n    var x = event.clientX;\n    var y = event.clientY;\n    contextInstance.startCoords = { x: x - positionX, y: y - positionY };\n};\nvar handleTouchPanningSetup = function (contextInstance, event) {\n    var touches = event.touches;\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY;\n    contextInstance.isPanning = true;\n    // Panning with touch\n    var oneFingerTouch = touches.length === 1;\n    if (oneFingerTouch) {\n        var x = touches[0].clientX;\n        var y = touches[0].clientY;\n        contextInstance.startCoords = { x: x - positionX, y: y - positionY };\n    }\n};\nfunction handlePanToBounds(contextInstance) {\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale;\n    var _b = contextInstance.setup, disabled = _b.disabled, limitToBounds = _b.limitToBounds, centerZoomedOut = _b.centerZoomedOut;\n    var wrapperComponent = contextInstance.wrapperComponent;\n    if (disabled || !wrapperComponent || !contextInstance.bounds)\n        return;\n    var _c = contextInstance.bounds, maxPositionX = _c.maxPositionX, minPositionX = _c.minPositionX, maxPositionY = _c.maxPositionY, minPositionY = _c.minPositionY;\n    var xChanged = positionX > maxPositionX || positionX < minPositionX;\n    var yChanged = positionY > maxPositionY || positionY < minPositionY;\n    var mousePosX = positionX > maxPositionX\n        ? wrapperComponent.offsetWidth\n        : contextInstance.setup.minPositionX || 0;\n    var mousePosY = positionY > maxPositionY\n        ? wrapperComponent.offsetHeight\n        : contextInstance.setup.minPositionY || 0;\n    var _d = handleCalculateZoomPositions(contextInstance, mousePosX, mousePosY, scale, contextInstance.bounds, limitToBounds || centerZoomedOut), x = _d.x, y = _d.y;\n    return {\n        scale: scale,\n        positionX: xChanged ? x : positionX,\n        positionY: yChanged ? y : positionY,\n    };\n}\nfunction handleNewPosition(contextInstance, newPositionX, newPositionY, paddingValueX, paddingValueY) {\n    var limitToBounds = contextInstance.setup.limitToBounds;\n    var wrapperComponent = contextInstance.wrapperComponent, bounds = contextInstance.bounds;\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    var hasPositionXChanged = newPositionX !== positionX;\n    var hasPositionYChanged = newPositionY !== positionY;\n    var hasNewPosition = !hasPositionXChanged || !hasPositionYChanged;\n    if (!wrapperComponent || hasNewPosition || !bounds) {\n        return;\n    }\n    var _b = getMouseBoundedPosition(newPositionX, newPositionY, bounds, limitToBounds, paddingValueX, paddingValueY, wrapperComponent), x = _b.x, y = _b.y;\n    contextInstance.setTransformState(scale, x, y);\n}\nvar getPanningClientPosition = function (contextInstance, clientX, clientY) {\n    var startCoords = contextInstance.startCoords, transformState = contextInstance.transformState;\n    var panning = contextInstance.setup.panning;\n    var lockAxisX = panning.lockAxisX, lockAxisY = panning.lockAxisY;\n    var positionX = transformState.positionX, positionY = transformState.positionY;\n    if (!startCoords) {\n        return { x: positionX, y: positionY };\n    }\n    var mouseX = clientX - startCoords.x;\n    var mouseY = clientY - startCoords.y;\n    var newPositionX = lockAxisX ? positionX : mouseX;\n    var newPositionY = lockAxisY ? positionY : mouseY;\n    return { x: newPositionX, y: newPositionY };\n};\nvar getPaddingValue = function (contextInstance, size) {\n    var setup = contextInstance.setup, transformState = contextInstance.transformState;\n    var scale = transformState.scale;\n    var minScale = setup.minScale;\n    if (size > 0 && scale >= minScale) {\n        return size;\n    }\n    return 0;\n};\n\nvar isVelocityCalculationAllowed = function (contextInstance) {\n    var mounted = contextInstance.mounted;\n    var _a = contextInstance.setup, disabled = _a.disabled, velocityAnimation = _a.velocityAnimation;\n    var scale = contextInstance.transformState.scale;\n    var disabledVelocity = velocityAnimation.disabled;\n    var isAllowed = !disabledVelocity || scale > 1 || !disabled || mounted;\n    if (!isAllowed)\n        return false;\n    return true;\n};\nvar isVelocityAllowed = function (contextInstance) {\n    var mounted = contextInstance.mounted, velocity = contextInstance.velocity, bounds = contextInstance.bounds;\n    var _a = contextInstance.setup, disabled = _a.disabled, velocityAnimation = _a.velocityAnimation;\n    var scale = contextInstance.transformState.scale;\n    var disabledVelocity = velocityAnimation.disabled;\n    var isAllowed = !disabledVelocity || scale > 1 || !disabled || mounted;\n    if (!isAllowed)\n        return false;\n    if (!velocity || !bounds)\n        return false;\n    return true;\n};\nfunction getVelocityMoveTime(contextInstance, velocity) {\n    var velocityAnimation = contextInstance.setup.velocityAnimation;\n    var equalToMove = velocityAnimation.equalToMove, animationTime = velocityAnimation.animationTime, sensitivity = velocityAnimation.sensitivity;\n    if (equalToMove) {\n        return animationTime * velocity * sensitivity;\n    }\n    return animationTime;\n}\nfunction getVelocityPosition(newPosition, startPosition, currentPosition, isLocked, limitToBounds, minPosition, maxPosition, minTarget, maxTarget, step) {\n    if (limitToBounds) {\n        if (startPosition > maxPosition && currentPosition > maxPosition) {\n            var calculatedPosition = maxPosition + (newPosition - maxPosition) * step;\n            if (calculatedPosition > maxTarget)\n                return maxTarget;\n            if (calculatedPosition < maxPosition)\n                return maxPosition;\n            return calculatedPosition;\n        }\n        if (startPosition < minPosition && currentPosition < minPosition) {\n            var calculatedPosition = minPosition + (newPosition - minPosition) * step;\n            if (calculatedPosition < minTarget)\n                return minTarget;\n            if (calculatedPosition > minPosition)\n                return minPosition;\n            return calculatedPosition;\n        }\n    }\n    if (isLocked)\n        return startPosition;\n    return boundLimiter(newPosition, minPosition, maxPosition, limitToBounds);\n}\n\nfunction getSizeMultiplier(wrapperComponent, equalToMove) {\n    var defaultMultiplier = 1;\n    if (equalToMove) {\n        return Math.min(defaultMultiplier, wrapperComponent.offsetWidth / window.innerWidth);\n    }\n    return defaultMultiplier;\n}\nfunction handleCalculateVelocity(contextInstance, position) {\n    var isAllowed = isVelocityCalculationAllowed(contextInstance);\n    if (!isAllowed) {\n        return;\n    }\n    var lastMousePosition = contextInstance.lastMousePosition, velocityTime = contextInstance.velocityTime, setup = contextInstance.setup;\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var equalToMove = setup.velocityAnimation.equalToMove;\n    var now = Date.now();\n    if (lastMousePosition && velocityTime && wrapperComponent) {\n        var sizeMultiplier = getSizeMultiplier(wrapperComponent, equalToMove);\n        var distanceX = position.x - lastMousePosition.x;\n        var distanceY = position.y - lastMousePosition.y;\n        var velocityX = distanceX / sizeMultiplier;\n        var velocityY = distanceY / sizeMultiplier;\n        var interval = now - velocityTime;\n        var speed = distanceX * distanceX + distanceY * distanceY;\n        var velocity = Math.sqrt(speed) / interval;\n        contextInstance.velocity = { velocityX: velocityX, velocityY: velocityY, total: velocity };\n    }\n    contextInstance.lastMousePosition = position;\n    contextInstance.velocityTime = now;\n}\nfunction handleVelocityPanning(contextInstance) {\n    var velocity = contextInstance.velocity, bounds = contextInstance.bounds, setup = contextInstance.setup, wrapperComponent = contextInstance.wrapperComponent;\n    var isAllowed = isVelocityAllowed(contextInstance);\n    if (!isAllowed || !velocity || !bounds || !wrapperComponent) {\n        return;\n    }\n    var velocityX = velocity.velocityX, velocityY = velocity.velocityY, total = velocity.total;\n    var maxPositionX = bounds.maxPositionX, minPositionX = bounds.minPositionX, maxPositionY = bounds.maxPositionY, minPositionY = bounds.minPositionY;\n    var limitToBounds = setup.limitToBounds, alignmentAnimation = setup.alignmentAnimation;\n    var zoomAnimation = setup.zoomAnimation, panning = setup.panning;\n    var lockAxisY = panning.lockAxisY, lockAxisX = panning.lockAxisX;\n    var animationType = zoomAnimation.animationType;\n    var sizeX = alignmentAnimation.sizeX, sizeY = alignmentAnimation.sizeY, velocityAlignmentTime = alignmentAnimation.velocityAlignmentTime;\n    var alignAnimationTime = velocityAlignmentTime;\n    var moveAnimationTime = getVelocityMoveTime(contextInstance, total);\n    var finalAnimationTime = Math.max(moveAnimationTime, alignAnimationTime);\n    var paddingValueX = getPaddingValue(contextInstance, sizeX);\n    var paddingValueY = getPaddingValue(contextInstance, sizeY);\n    var paddingX = (paddingValueX * wrapperComponent.offsetWidth) / 100;\n    var paddingY = (paddingValueY * wrapperComponent.offsetHeight) / 100;\n    var maxTargetX = maxPositionX + paddingX;\n    var minTargetX = minPositionX - paddingX;\n    var maxTargetY = maxPositionY + paddingY;\n    var minTargetY = minPositionY - paddingY;\n    var startState = contextInstance.transformState;\n    var startTime = new Date().getTime();\n    handleSetupAnimation(contextInstance, animationType, finalAnimationTime, function (step) {\n        var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n        var frameTime = new Date().getTime() - startTime;\n        var animationProgress = frameTime / alignAnimationTime;\n        var alignAnimation = animations[alignmentAnimation.animationType];\n        var alignStep = 1 - alignAnimation(Math.min(1, animationProgress));\n        var customStep = 1 - step;\n        var newPositionX = positionX + velocityX * customStep;\n        var newPositionY = positionY + velocityY * customStep;\n        var currentPositionX = getVelocityPosition(newPositionX, startState.positionX, positionX, lockAxisX, limitToBounds, minPositionX, maxPositionX, minTargetX, maxTargetX, alignStep);\n        var currentPositionY = getVelocityPosition(newPositionY, startState.positionY, positionY, lockAxisY, limitToBounds, minPositionY, maxPositionY, minTargetY, maxTargetY, alignStep);\n        if (positionX !== newPositionX || positionY !== newPositionY) {\n            contextInstance.setTransformState(scale, currentPositionX, currentPositionY);\n        }\n    });\n}\n\nfunction handlePanningStart(contextInstance, event) {\n    var scale = contextInstance.transformState.scale;\n    handleCancelAnimation(contextInstance);\n    handleCalculateBounds(contextInstance, scale);\n    if (event.touches) {\n        handleTouchPanningSetup(contextInstance, event);\n    }\n    else {\n        handlePanningSetup(contextInstance, event);\n    }\n}\nfunction handlePanning(contextInstance, clientX, clientY) {\n    var startCoords = contextInstance.startCoords, setup = contextInstance.setup;\n    var _a = setup.alignmentAnimation, sizeX = _a.sizeX, sizeY = _a.sizeY;\n    if (!startCoords)\n        return;\n    var _b = getPanningClientPosition(contextInstance, clientX, clientY), x = _b.x, y = _b.y;\n    var paddingValueX = getPaddingValue(contextInstance, sizeX);\n    var paddingValueY = getPaddingValue(contextInstance, sizeY);\n    handleCalculateVelocity(contextInstance, { x: x, y: y });\n    handleNewPosition(contextInstance, x, y, paddingValueX, paddingValueY);\n}\nfunction handlePanningEnd(contextInstance) {\n    if (contextInstance.isPanning) {\n        var velocityDisabled = contextInstance.setup.panning.velocityDisabled;\n        var velocity = contextInstance.velocity, wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n        contextInstance.isPanning = false;\n        contextInstance.animate = false;\n        contextInstance.animation = null;\n        var wrapperRect = wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.getBoundingClientRect();\n        var contentRect = contentComponent === null || contentComponent === void 0 ? void 0 : contentComponent.getBoundingClientRect();\n        var wrapperWidth = (wrapperRect === null || wrapperRect === void 0 ? void 0 : wrapperRect.width) || 0;\n        var wrapperHeight = (wrapperRect === null || wrapperRect === void 0 ? void 0 : wrapperRect.height) || 0;\n        var contentWidth = (contentRect === null || contentRect === void 0 ? void 0 : contentRect.width) || 0;\n        var contentHeight = (contentRect === null || contentRect === void 0 ? void 0 : contentRect.height) || 0;\n        var isZoomed = wrapperWidth < contentWidth || wrapperHeight < contentHeight;\n        var shouldAnimate = !velocityDisabled && velocity && (velocity === null || velocity === void 0 ? void 0 : velocity.total) > 0.1 && isZoomed;\n        if (shouldAnimate) {\n            handleVelocityPanning(contextInstance);\n        }\n        else {\n            handleAlignToBounds(contextInstance);\n        }\n    }\n}\nfunction handleAlignToBounds(contextInstance) {\n    var scale = contextInstance.transformState.scale;\n    var _a = contextInstance.setup, minScale = _a.minScale, alignmentAnimation = _a.alignmentAnimation;\n    var disabled = alignmentAnimation.disabled, sizeX = alignmentAnimation.sizeX, sizeY = alignmentAnimation.sizeY, animationTime = alignmentAnimation.animationTime, animationType = alignmentAnimation.animationType;\n    var isDisabled = disabled || scale < minScale || (!sizeX && !sizeY);\n    if (isDisabled)\n        return;\n    var targetState = handlePanToBounds(contextInstance);\n    if (targetState) {\n        animate(contextInstance, targetState, animationTime, animationType);\n    }\n}\n\nfunction handleAlignToScaleBounds(contextInstance, mousePositionX, mousePositionY) {\n    var scale = contextInstance.transformState.scale;\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var _a = contextInstance.setup, minScale = _a.minScale, limitToBounds = _a.limitToBounds, zoomAnimation = _a.zoomAnimation;\n    var disabled = zoomAnimation.disabled, animationTime = zoomAnimation.animationTime, animationType = zoomAnimation.animationType;\n    var isDisabled = disabled || scale >= minScale;\n    if (scale >= 1 || limitToBounds) {\n        // fire fit to bounds animation\n        handleAlignToBounds(contextInstance);\n    }\n    if (isDisabled || !wrapperComponent || !contextInstance.mounted)\n        return;\n    var mouseX = mousePositionX || wrapperComponent.offsetWidth / 2;\n    var mouseY = mousePositionY || wrapperComponent.offsetHeight / 2;\n    var targetState = handleZoomToPoint(contextInstance, minScale, mouseX, mouseY);\n    if (targetState) {\n        animate(contextInstance, targetState, animationTime, animationType);\n    }\n}\nfunction handleZoomToPoint(contextInstance, scale, mouseX, mouseY) {\n    var _a = contextInstance.setup, minScale = _a.minScale, maxScale = _a.maxScale, limitToBounds = _a.limitToBounds;\n    var newScale = checkZoomBounds(roundNumber(scale, 2), minScale, maxScale, 0, false);\n    var bounds = handleCalculateBounds(contextInstance, newScale);\n    var _b = handleCalculateZoomPositions(contextInstance, mouseX, mouseY, newScale, bounds, limitToBounds), x = _b.x, y = _b.y;\n    return { scale: newScale, positionX: x, positionY: y };\n}\n\nvar initialState = {\n    previousScale: 1,\n    scale: 1,\n    positionX: 0,\n    positionY: 0,\n};\nvar contextInitialState = __assign(__assign({}, initialState), { setComponents: function () { return undefined; }, contextInstance: null });\nvar initialSetup = {\n    disabled: false,\n    minPositionX: null,\n    maxPositionX: null,\n    minPositionY: null,\n    maxPositionY: null,\n    minScale: 1,\n    maxScale: 8,\n    limitToBounds: true,\n    centerZoomedOut: false,\n    centerOnInit: false,\n    wheel: {\n        step: 0.2,\n        disabled: false,\n        wheelDisabled: false,\n        touchPadDisabled: false,\n        activationKeys: [],\n        excluded: [],\n    },\n    panning: {\n        disabled: false,\n        velocityDisabled: false,\n        lockAxisX: false,\n        lockAxisY: false,\n        activationKeys: [],\n        excluded: [],\n    },\n    pinch: {\n        step: 5,\n        disabled: false,\n        excluded: [],\n    },\n    doubleClick: {\n        disabled: false,\n        step: 0.7,\n        mode: \"zoomIn\",\n        animationType: \"easeOut\",\n        animationTime: 200,\n        excluded: [],\n    },\n    zoomAnimation: {\n        disabled: false,\n        size: 0.4,\n        animationTime: 200,\n        animationType: \"easeOut\",\n    },\n    alignmentAnimation: {\n        disabled: false,\n        sizeX: 100,\n        sizeY: 100,\n        animationTime: 200,\n        velocityAlignmentTime: 400,\n        animationType: \"easeOut\",\n    },\n    velocityAnimation: {\n        disabled: false,\n        sensitivity: 1,\n        animationTime: 400,\n        animationType: \"easeOut\",\n        equalToMove: true,\n    },\n};\n\nvar createState = function (props) {\n    var _a, _b, _c, _d;\n    return {\n        previousScale: (_a = props.initialScale) !== null && _a !== void 0 ? _a : initialState.scale,\n        scale: (_b = props.initialScale) !== null && _b !== void 0 ? _b : initialState.scale,\n        positionX: (_c = props.initialPositionX) !== null && _c !== void 0 ? _c : initialState.positionX,\n        positionY: (_d = props.initialPositionY) !== null && _d !== void 0 ? _d : initialState.positionY,\n    };\n};\nvar createSetup = function (props) {\n    var newSetup = __assign({}, initialSetup);\n    Object.keys(props).forEach(function (key) {\n        var validValue = typeof props[key] !== \"undefined\";\n        var validParameter = typeof initialSetup[key] !== \"undefined\";\n        if (validParameter && validValue) {\n            var dataType = Object.prototype.toString.call(initialSetup[key]);\n            var isObject = dataType === \"[object Object]\";\n            var isArray = dataType === \"[object Array]\";\n            if (isObject) {\n                newSetup[key] = __assign(__assign({}, initialSetup[key]), props[key]);\n            }\n            else if (isArray) {\n                newSetup[key] = __spreadArray(__spreadArray([], initialSetup[key]), props[key]);\n            }\n            else {\n                newSetup[key] = props[key];\n            }\n        }\n    });\n    return newSetup;\n};\n\nvar handleCalculateButtonZoom = function (contextInstance, delta, step) {\n    var scale = contextInstance.transformState.scale;\n    var wrapperComponent = contextInstance.wrapperComponent, setup = contextInstance.setup;\n    var maxScale = setup.maxScale, minScale = setup.minScale, zoomAnimation = setup.zoomAnimation;\n    var size = zoomAnimation.size;\n    if (!wrapperComponent) {\n        throw new Error(\"Wrapper is not mounted\");\n    }\n    var targetScale = scale * Math.exp(delta * step);\n    var newScale = checkZoomBounds(roundNumber(targetScale, 3), minScale, maxScale, size, false);\n    return newScale;\n};\nfunction handleZoomToViewCenter(contextInstance, delta, step, animationTime, animationType) {\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    if (!wrapperComponent)\n        return console.error(\"No WrapperComponent found\");\n    var wrapperWidth = wrapperComponent.offsetWidth;\n    var wrapperHeight = wrapperComponent.offsetHeight;\n    var mouseX = (wrapperWidth / 2 - positionX) / scale;\n    var mouseY = (wrapperHeight / 2 - positionY) / scale;\n    var newScale = handleCalculateButtonZoom(contextInstance, delta, step);\n    var targetState = handleZoomToPoint(contextInstance, newScale, mouseX, mouseY);\n    if (!targetState) {\n        return console.error(\"Error during zoom event. New transformation state was not calculated.\");\n    }\n    animate(contextInstance, targetState, animationTime, animationType);\n}\nfunction resetTransformations(contextInstance, animationTime, animationType) {\n    var setup = contextInstance.setup, wrapperComponent = contextInstance.wrapperComponent;\n    var limitToBounds = setup.limitToBounds;\n    var initialTransformation = createState(contextInstance.props);\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    if (!wrapperComponent)\n        return;\n    var newBounds = calculateBounds(contextInstance, initialTransformation.scale);\n    var boundedPositions = getMouseBoundedPosition(initialTransformation.positionX, initialTransformation.positionY, newBounds, limitToBounds, 0, 0, wrapperComponent);\n    var newState = {\n        scale: initialTransformation.scale,\n        positionX: boundedPositions.x,\n        positionY: boundedPositions.y,\n    };\n    if (scale === initialTransformation.scale &&\n        positionX === initialTransformation.positionX &&\n        positionY === initialTransformation.positionY) {\n        return;\n    }\n    animate(contextInstance, newState, animationTime, animationType);\n}\nfunction calculateZoomToNode(contextInstance, node, customZoom) {\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var _a = contextInstance.setup, limitToBounds = _a.limitToBounds, minScale = _a.minScale, maxScale = _a.maxScale;\n    if (!wrapperComponent)\n        return initialState;\n    var wrapperRect = wrapperComponent.getBoundingClientRect();\n    var nodeRect = getOffset(node);\n    var nodeLeft = nodeRect.x;\n    var nodeTop = nodeRect.y;\n    var nodeWidth = node.offsetWidth;\n    var nodeHeight = node.offsetHeight;\n    var scaleX = wrapperComponent.offsetWidth / nodeWidth;\n    var scaleY = wrapperComponent.offsetHeight / nodeHeight;\n    var newScale = checkZoomBounds(customZoom || Math.min(scaleX, scaleY), minScale, maxScale, 0, false);\n    var offsetX = (wrapperRect.width - nodeWidth * newScale) / 2;\n    var offsetY = (wrapperRect.height - nodeHeight * newScale) / 2;\n    var newPositionX = (wrapperRect.left - nodeLeft) * newScale + offsetX;\n    var newPositionY = (wrapperRect.top - nodeTop) * newScale + offsetY;\n    var bounds = calculateBounds(contextInstance, newScale);\n    var _b = getMouseBoundedPosition(newPositionX, newPositionY, bounds, limitToBounds, 0, 0, wrapperComponent), x = _b.x, y = _b.y;\n    return { positionX: x, positionY: y, scale: newScale };\n}\nfunction getOffset(element) {\n    var el = element;\n    var offsetLeft = 0;\n    var offsetTop = 0;\n    while (el) {\n        offsetLeft += el.offsetLeft;\n        offsetTop += el.offsetTop;\n        el = el.offsetParent;\n    }\n    return {\n        x: offsetLeft,\n        y: offsetTop,\n    };\n}\nfunction isValidZoomNode(node) {\n    if (!node) {\n        console.error(\"Zoom node not found\");\n        return false;\n    }\n    else if ((node === null || node === void 0 ? void 0 : node.offsetWidth) === undefined ||\n        (node === null || node === void 0 ? void 0 : node.offsetHeight) === undefined) {\n        console.error(\"Zoom node is not valid - it must contain offsetWidth and offsetHeight\");\n        return false;\n    }\n    return true;\n}\n\nvar zoomIn = function (contextInstance) { return function (step, animationTime, animationType) {\n    if (step === void 0) { step = 0.5; }\n    if (animationTime === void 0) { animationTime = 300; }\n    if (animationType === void 0) { animationType = \"easeOut\"; }\n    handleZoomToViewCenter(contextInstance, 1, step, animationTime, animationType);\n}; };\nvar zoomOut = function (contextInstance) { return function (step, animationTime, animationType) {\n    if (step === void 0) { step = 0.5; }\n    if (animationTime === void 0) { animationTime = 300; }\n    if (animationType === void 0) { animationType = \"easeOut\"; }\n    handleZoomToViewCenter(contextInstance, -1, step, animationTime, animationType);\n}; };\nvar setTransform = function (contextInstance) { return function (newPositionX, newPositionY, newScale, animationTime, animationType) {\n    if (animationTime === void 0) { animationTime = 300; }\n    if (animationType === void 0) { animationType = \"easeOut\"; }\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale;\n    var wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n    var disabled = contextInstance.setup.disabled;\n    if (disabled || !wrapperComponent || !contentComponent)\n        return;\n    var targetState = {\n        positionX: isNaN(newPositionX) ? positionX : newPositionX,\n        positionY: isNaN(newPositionY) ? positionY : newPositionY,\n        scale: isNaN(newScale) ? scale : newScale,\n    };\n    animate(contextInstance, targetState, animationTime, animationType);\n}; };\nvar resetTransform = function (contextInstance) { return function (animationTime, animationType) {\n    if (animationTime === void 0) { animationTime = 200; }\n    if (animationType === void 0) { animationType = \"easeOut\"; }\n    resetTransformations(contextInstance, animationTime, animationType);\n}; };\nvar centerView = function (contextInstance) { return function (scale, animationTime, animationType) {\n    if (animationTime === void 0) { animationTime = 200; }\n    if (animationType === void 0) { animationType = \"easeOut\"; }\n    var transformState = contextInstance.transformState, wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n    if (wrapperComponent && contentComponent) {\n        var targetState = getCenterPosition(scale || transformState.scale, wrapperComponent, contentComponent);\n        animate(contextInstance, targetState, animationTime, animationType);\n    }\n}; };\nvar zoomToElement = function (contextInstance) { return function (node, scale, animationTime, animationType) {\n    if (animationTime === void 0) { animationTime = 600; }\n    if (animationType === void 0) { animationType = \"easeOut\"; }\n    handleCancelAnimation(contextInstance);\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var target = typeof node === \"string\" ? document.getElementById(node) : node;\n    if (wrapperComponent &&\n        isValidZoomNode(target) &&\n        target &&\n        wrapperComponent.contains(target)) {\n        var targetState = calculateZoomToNode(contextInstance, target, scale);\n        animate(contextInstance, targetState, animationTime, animationType);\n    }\n}; };\n\nvar getContext = function (contextInstance) {\n    return {\n        instance: contextInstance,\n        state: contextInstance.transformState,\n        zoomIn: zoomIn(contextInstance),\n        zoomOut: zoomOut(contextInstance),\n        setTransform: setTransform(contextInstance),\n        resetTransform: resetTransform(contextInstance),\n        centerView: centerView(contextInstance),\n        zoomToElement: zoomToElement(contextInstance),\n    };\n};\n\n// We want to make event listeners non-passive, and to do so have to check\n// that browsers support EventListenerOptions in the first place.\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nvar passiveSupported = false;\nfunction makePassiveEventOption() {\n    try {\n        var options = {\n            get passive() {\n                // This function will be called when the browser\n                //   attempts to access the passive property.\n                passiveSupported = true;\n                return false;\n            },\n        };\n        return options;\n    }\n    catch (err) {\n        passiveSupported = false;\n        return passiveSupported;\n    }\n}\n\nvar isExcludedNode = function (node, excluded) {\n    var targetTagName = node.tagName.toUpperCase();\n    var isExcludedTag = excluded.find(function (tag) { return tag.toUpperCase() === targetTagName; });\n    if (isExcludedTag)\n        return true;\n    var isExcludedClassName = excluded.find(function (className) {\n        return node.classList.contains(className);\n    });\n    if (isExcludedClassName)\n        return true;\n    return false;\n};\nvar cancelTimeout = function (timeout) {\n    if (timeout) {\n        clearTimeout(timeout);\n    }\n};\n\nvar getTransformStyles = function (x, y, scale) {\n    return \"translate3d(\" + x + \"px, \" + y + \"px, 0) scale(\" + scale + \")\";\n};\nvar getCenterPosition = function (scale, wrapperComponent, contentComponent) {\n    var contentWidth = contentComponent.offsetWidth * scale;\n    var contentHeight = contentComponent.offsetHeight * scale;\n    var centerPositionX = (wrapperComponent.offsetWidth - contentWidth) / 2;\n    var centerPositionY = (wrapperComponent.offsetHeight - contentHeight) / 2;\n    return {\n        scale: scale,\n        positionX: centerPositionX,\n        positionY: centerPositionY,\n    };\n};\n\nvar isWheelAllowed = function (contextInstance, event) {\n    var _a = contextInstance.setup.wheel, disabled = _a.disabled, wheelDisabled = _a.wheelDisabled, touchPadDisabled = _a.touchPadDisabled, excluded = _a.excluded;\n    var isInitialized = contextInstance.isInitialized, isPanning = contextInstance.isPanning;\n    var target = event.target;\n    var isAllowed = isInitialized && !isPanning && !disabled && target;\n    if (!isAllowed)\n        return false;\n    // Event ctrlKey detects if touchpad action is executing wheel or pinch gesture\n    if (wheelDisabled && !event.ctrlKey)\n        return false;\n    if (touchPadDisabled && event.ctrlKey)\n        return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded)\n        return false;\n    return true;\n};\nfunction getDelta(event, customDelta) {\n    var deltaY = event ? (event.deltaY < 0 ? 1 : -1) : 0;\n    var delta = checkIsNumber(customDelta, deltaY);\n    return delta;\n}\nfunction getMousePosition(event, contentComponent, scale) {\n    var contentRect = contentComponent.getBoundingClientRect();\n    var mouseX = 0;\n    var mouseY = 0;\n    if (\"clientX\" in event) {\n        // mouse position x, y over wrapper component\n        mouseX = (event.clientX - contentRect.left) / scale;\n        mouseY = (event.clientY - contentRect.top) / scale;\n    }\n    else {\n        var touch = event.touches[0];\n        mouseX = (touch.clientX - contentRect.left) / scale;\n        mouseY = (touch.clientY - contentRect.top) / scale;\n    }\n    if (isNaN(mouseX) || isNaN(mouseY))\n        console.error(\"No mouse or touch offset found\");\n    return {\n        x: mouseX,\n        y: mouseY,\n    };\n}\nvar handleCalculateWheelZoom = function (contextInstance, delta, step, disablePadding, getTarget) {\n    var scale = contextInstance.transformState.scale;\n    var wrapperComponent = contextInstance.wrapperComponent, setup = contextInstance.setup;\n    var maxScale = setup.maxScale, minScale = setup.minScale, zoomAnimation = setup.zoomAnimation;\n    var size = zoomAnimation.size, disabled = zoomAnimation.disabled;\n    if (!wrapperComponent) {\n        throw new Error(\"Wrapper is not mounted\");\n    }\n    var targetScale = scale + delta * (scale - scale * step) * step;\n    if (getTarget)\n        return targetScale;\n    var paddingEnabled = disablePadding ? false : !disabled;\n    var newScale = checkZoomBounds(roundNumber(targetScale, 3), minScale, maxScale, size, paddingEnabled);\n    return newScale;\n};\nvar handleWheelZoomStop = function (contextInstance, event) {\n    var previousWheelEvent = contextInstance.previousWheelEvent;\n    var scale = contextInstance.transformState.scale;\n    var _a = contextInstance.setup, maxScale = _a.maxScale, minScale = _a.minScale;\n    if (!previousWheelEvent)\n        return false;\n    if (scale < maxScale || scale > minScale)\n        return true;\n    if (Math.sign(previousWheelEvent.deltaY) !== Math.sign(event.deltaY))\n        return true;\n    if (previousWheelEvent.deltaY > 0 && previousWheelEvent.deltaY < event.deltaY)\n        return true;\n    if (previousWheelEvent.deltaY < 0 && previousWheelEvent.deltaY > event.deltaY)\n        return true;\n    if (Math.sign(previousWheelEvent.deltaY) !== Math.sign(event.deltaY))\n        return true;\n    return false;\n};\n\nvar isPinchStartAllowed = function (contextInstance, event) {\n    var _a = contextInstance.setup.pinch, disabled = _a.disabled, excluded = _a.excluded;\n    var isInitialized = contextInstance.isInitialized;\n    var target = event.target;\n    var isAllowed = isInitialized && !disabled && target;\n    if (!isAllowed)\n        return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded)\n        return false;\n    return true;\n};\nvar isPinchAllowed = function (contextInstance) {\n    var disabled = contextInstance.setup.pinch.disabled;\n    var isInitialized = contextInstance.isInitialized, pinchStartDistance = contextInstance.pinchStartDistance;\n    var isAllowed = isInitialized && !disabled && pinchStartDistance;\n    if (!isAllowed)\n        return false;\n    return true;\n};\nvar calculateTouchMidPoint = function (event, scale, contentComponent) {\n    var contentRect = contentComponent.getBoundingClientRect();\n    var touches = event.touches;\n    var firstPointX = roundNumber(touches[0].clientX - contentRect.left, 5);\n    var firstPointY = roundNumber(touches[0].clientY - contentRect.top, 5);\n    var secondPointX = roundNumber(touches[1].clientX - contentRect.left, 5);\n    var secondPointY = roundNumber(touches[1].clientY - contentRect.top, 5);\n    return {\n        x: (firstPointX + secondPointX) / 2 / scale,\n        y: (firstPointY + secondPointY) / 2 / scale,\n    };\n};\nvar getTouchDistance = function (event) {\n    return Math.sqrt(Math.pow(event.touches[0].pageX - event.touches[1].pageX, 2) +\n        Math.pow(event.touches[0].pageY - event.touches[1].pageY, 2));\n};\nvar calculatePinchZoom = function (contextInstance, currentDistance) {\n    var pinchStartScale = contextInstance.pinchStartScale, pinchStartDistance = contextInstance.pinchStartDistance, setup = contextInstance.setup;\n    var maxScale = setup.maxScale, minScale = setup.minScale, zoomAnimation = setup.zoomAnimation;\n    var size = zoomAnimation.size, disabled = zoomAnimation.disabled;\n    if (!pinchStartScale || pinchStartDistance === null || !currentDistance) {\n        throw new Error(\"Pinch touches distance was not provided\");\n    }\n    if (currentDistance < 0) {\n        return contextInstance.transformState.scale;\n    }\n    var touchProportion = currentDistance / pinchStartDistance;\n    var scaleDifference = touchProportion * pinchStartScale;\n    return checkZoomBounds(roundNumber(scaleDifference, 2), minScale, maxScale, size, !disabled);\n};\n\nvar wheelStopEventTime = 160;\nvar wheelAnimationTime = 100;\nvar handleWheelStart = function (contextInstance, event) {\n    var _a = contextInstance.props, onWheelStart = _a.onWheelStart, onZoomStart = _a.onZoomStart;\n    if (!contextInstance.wheelStopEventTimer) {\n        handleCancelAnimation(contextInstance);\n        handleCallback(getContext(contextInstance), event, onWheelStart);\n        handleCallback(getContext(contextInstance), event, onZoomStart);\n    }\n};\nvar handleWheelZoom = function (contextInstance, event) {\n    var _a = contextInstance.props, onWheel = _a.onWheel, onZoom = _a.onZoom;\n    var contentComponent = contextInstance.contentComponent, setup = contextInstance.setup, transformState = contextInstance.transformState;\n    var scale = transformState.scale;\n    var limitToBounds = setup.limitToBounds, centerZoomedOut = setup.centerZoomedOut, zoomAnimation = setup.zoomAnimation, wheel = setup.wheel;\n    var size = zoomAnimation.size, disabled = zoomAnimation.disabled;\n    var step = wheel.step;\n    if (!contentComponent) {\n        throw new Error(\"Component not mounted\");\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    var delta = getDelta(event, null);\n    var newScale = handleCalculateWheelZoom(contextInstance, delta, step, !event.ctrlKey);\n    // if scale not change\n    if (scale === newScale)\n        return;\n    var bounds = handleCalculateBounds(contextInstance, newScale);\n    var mousePosition = getMousePosition(event, contentComponent, scale);\n    var isPaddingDisabled = disabled || size === 0 || centerZoomedOut;\n    var isLimitedToBounds = limitToBounds && isPaddingDisabled;\n    var _b = handleCalculateZoomPositions(contextInstance, mousePosition.x, mousePosition.y, newScale, bounds, isLimitedToBounds), x = _b.x, y = _b.y;\n    contextInstance.previousWheelEvent = event;\n    contextInstance.setTransformState(newScale, x, y);\n    handleCallback(getContext(contextInstance), event, onWheel);\n    handleCallback(getContext(contextInstance), event, onZoom);\n};\nvar handleWheelStop = function (contextInstance, event) {\n    var _a = contextInstance.props, onWheelStop = _a.onWheelStop, onZoomStop = _a.onZoomStop;\n    // fire animation\n    cancelTimeout(contextInstance.wheelAnimationTimer);\n    contextInstance.wheelAnimationTimer = setTimeout(function () {\n        if (!contextInstance.mounted)\n            return;\n        handleAlignToScaleBounds(contextInstance, event.x, event.y);\n        contextInstance.wheelAnimationTimer = null;\n    }, wheelAnimationTime);\n    // Wheel stop event\n    var hasStoppedZooming = handleWheelZoomStop(contextInstance, event);\n    if (hasStoppedZooming) {\n        cancelTimeout(contextInstance.wheelStopEventTimer);\n        contextInstance.wheelStopEventTimer = setTimeout(function () {\n            if (!contextInstance.mounted)\n                return;\n            contextInstance.wheelStopEventTimer = null;\n            handleCallback(getContext(contextInstance), event, onWheelStop);\n            handleCallback(getContext(contextInstance), event, onZoomStop);\n        }, wheelStopEventTime);\n    }\n};\n\nvar handlePinchStart = function (contextInstance, event) {\n    var distance = getTouchDistance(event);\n    contextInstance.pinchStartDistance = distance;\n    contextInstance.lastDistance = distance;\n    contextInstance.pinchStartScale = contextInstance.transformState.scale;\n    contextInstance.isPanning = false;\n    handleCancelAnimation(contextInstance);\n};\nvar handlePinchZoom = function (contextInstance, event) {\n    var contentComponent = contextInstance.contentComponent, pinchStartDistance = contextInstance.pinchStartDistance;\n    var scale = contextInstance.transformState.scale;\n    var _a = contextInstance.setup, limitToBounds = _a.limitToBounds, centerZoomedOut = _a.centerZoomedOut, zoomAnimation = _a.zoomAnimation;\n    var disabled = zoomAnimation.disabled, size = zoomAnimation.size;\n    // if one finger starts from outside of wrapper\n    if (pinchStartDistance === null || !contentComponent)\n        return;\n    var midPoint = calculateTouchMidPoint(event, scale, contentComponent);\n    // if touches goes off of the wrapper element\n    if (!isFinite(midPoint.x) || !isFinite(midPoint.y))\n        return;\n    var currentDistance = getTouchDistance(event);\n    var newScale = calculatePinchZoom(contextInstance, currentDistance);\n    if (newScale === scale)\n        return;\n    var bounds = handleCalculateBounds(contextInstance, newScale);\n    var isPaddingDisabled = disabled || size === 0 || centerZoomedOut;\n    var isLimitedToBounds = limitToBounds && isPaddingDisabled;\n    var _b = handleCalculateZoomPositions(contextInstance, midPoint.x, midPoint.y, newScale, bounds, isLimitedToBounds), x = _b.x, y = _b.y;\n    contextInstance.pinchMidpoint = midPoint;\n    contextInstance.lastDistance = currentDistance;\n    contextInstance.setTransformState(newScale, x, y);\n};\nvar handlePinchStop = function (contextInstance) {\n    var pinchMidpoint = contextInstance.pinchMidpoint;\n    contextInstance.velocity = null;\n    contextInstance.lastDistance = null;\n    contextInstance.pinchMidpoint = null;\n    contextInstance.pinchStartScale = null;\n    contextInstance.pinchStartDistance = null;\n    handleAlignToScaleBounds(contextInstance, pinchMidpoint === null || pinchMidpoint === void 0 ? void 0 : pinchMidpoint.x, pinchMidpoint === null || pinchMidpoint === void 0 ? void 0 : pinchMidpoint.y);\n};\n\nfunction handleDoubleClick(contextInstance, event) {\n    var _a = contextInstance.setup.doubleClick, disabled = _a.disabled, mode = _a.mode, step = _a.step, animationTime = _a.animationTime, animationType = _a.animationType;\n    if (disabled)\n        return;\n    if (mode === \"reset\") {\n        return resetTransformations(contextInstance, animationTime, animationType);\n    }\n    var scale = contextInstance.transformState.scale;\n    var contentComponent = contextInstance.contentComponent;\n    if (!contentComponent)\n        return console.error(\"No ContentComponent found\");\n    var delta = mode === \"zoomOut\" ? -1 : 1;\n    var newScale = handleCalculateButtonZoom(contextInstance, delta, step);\n    var mousePosition = getMousePosition(event, contentComponent, scale);\n    var targetState = handleZoomToPoint(contextInstance, newScale, mousePosition.x, mousePosition.y);\n    if (!targetState) {\n        return console.error(\"Error during zoom event. New transformation state was not calculated.\");\n    }\n    animate(contextInstance, targetState, animationTime, animationType);\n}\nvar isDoubleClickAllowed = function (contextInstance, event) {\n    var isInitialized = contextInstance.isInitialized, setup = contextInstance.setup, wrapperComponent = contextInstance.wrapperComponent;\n    var _a = setup.doubleClick, disabled = _a.disabled, excluded = _a.excluded;\n    var target = event.target;\n    var isWrapperChild = wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.contains(target);\n    var isAllowed = isInitialized && target && isWrapperChild && !disabled;\n    if (!isAllowed)\n        return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded)\n        return false;\n    if (!isAllowed)\n        return false;\n    return true;\n};\n\nvar Context = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(contextInitialState);\nvar TransformContext = /** @class */ (function (_super) {\n    __extends(TransformContext, _super);\n    function TransformContext() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.mounted = true;\n        _this.transformState = createState(_this.props);\n        _this.setup = createSetup(_this.props);\n        // Components\n        _this.wrapperComponent = null;\n        _this.contentComponent = null;\n        // Initialization\n        _this.isInitialized = false;\n        _this.bounds = null;\n        // wheel helpers\n        _this.previousWheelEvent = null;\n        _this.wheelStopEventTimer = null;\n        _this.wheelAnimationTimer = null;\n        // panning helpers\n        _this.isPanning = false;\n        _this.startCoords = null;\n        _this.lastTouch = null;\n        // pinch helpers\n        _this.distance = null;\n        _this.lastDistance = null;\n        _this.pinchStartDistance = null;\n        _this.pinchStartScale = null;\n        _this.pinchMidpoint = null;\n        // velocity helpers\n        _this.velocity = null;\n        _this.velocityTime = null;\n        _this.lastMousePosition = null;\n        // animations helpers\n        _this.animate = false;\n        _this.animation = null;\n        _this.maxBounds = null;\n        // key press\n        _this.pressedKeys = {};\n        _this.handleInitializeWrapperEvents = function (wrapper) {\n            // Zooming events on wrapper\n            var passive = makePassiveEventOption();\n            wrapper.addEventListener(\"wheel\", _this.onWheelZoom, passive);\n            wrapper.addEventListener(\"dblclick\", _this.onDoubleClick, passive);\n            wrapper.addEventListener(\"touchstart\", _this.onTouchPanningStart, passive);\n            wrapper.addEventListener(\"touchmove\", _this.onTouchPanning, passive);\n            wrapper.addEventListener(\"touchend\", _this.onTouchPanningStop, passive);\n        };\n        _this.handleInitialize = function () {\n            var centerOnInit = _this.setup.centerOnInit;\n            _this.applyTransformation();\n            _this.forceUpdate();\n            if (centerOnInit) {\n                // this has to be redone once the right solution is found\n                // problem is - we need to execute it after mounted component specify it's height / width, images are fetched async so it's tricky\n                setTimeout(function () {\n                    if (_this.mounted) {\n                        _this.setCenter();\n                    }\n                }, 50);\n                setTimeout(function () {\n                    if (_this.mounted) {\n                        _this.setCenter();\n                    }\n                }, 100);\n                setTimeout(function () {\n                    if (_this.mounted) {\n                        _this.setCenter();\n                    }\n                }, 200);\n            }\n        };\n        //////////\n        // Zoom\n        //////////\n        _this.onWheelZoom = function (event) {\n            var disabled = _this.setup.disabled;\n            if (disabled)\n                return;\n            var isAllowed = isWheelAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            var keysPressed = _this.isPressingKeys(_this.setup.wheel.activationKeys);\n            if (!keysPressed)\n                return;\n            handleWheelStart(_this, event);\n            handleWheelZoom(_this, event);\n            handleWheelStop(_this, event);\n        };\n        //////////\n        // Pan\n        //////////\n        _this.onPanningStart = function (event) {\n            var disabled = _this.setup.disabled;\n            var onPanningStart = _this.props.onPanningStart;\n            if (disabled)\n                return;\n            var isAllowed = isPanningStartAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            var keysPressed = _this.isPressingKeys(_this.setup.panning.activationKeys);\n            if (!keysPressed)\n                return;\n            event.preventDefault();\n            event.stopPropagation();\n            handleCancelAnimation(_this);\n            handlePanningStart(_this, event);\n            handleCallback(getContext(_this), event, onPanningStart);\n        };\n        _this.onPanning = function (event) {\n            var disabled = _this.setup.disabled;\n            var onPanning = _this.props.onPanning;\n            if (disabled)\n                return;\n            var isAllowed = isPanningAllowed(_this);\n            if (!isAllowed)\n                return;\n            var keysPressed = _this.isPressingKeys(_this.setup.panning.activationKeys);\n            if (!keysPressed)\n                return;\n            event.preventDefault();\n            event.stopPropagation();\n            handlePanning(_this, event.clientX, event.clientY);\n            handleCallback(getContext(_this), event, onPanning);\n        };\n        _this.onPanningStop = function (event) {\n            var onPanningStop = _this.props.onPanningStop;\n            if (_this.isPanning) {\n                handlePanningEnd(_this);\n                handleCallback(getContext(_this), event, onPanningStop);\n            }\n        };\n        //////////\n        // Pinch\n        //////////\n        _this.onPinchStart = function (event) {\n            var disabled = _this.setup.disabled;\n            var _a = _this.props, onPinchingStart = _a.onPinchingStart, onZoomStart = _a.onZoomStart;\n            if (disabled)\n                return;\n            var isAllowed = isPinchStartAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            handlePinchStart(_this, event);\n            handleCancelAnimation(_this);\n            handleCallback(getContext(_this), event, onPinchingStart);\n            handleCallback(getContext(_this), event, onZoomStart);\n        };\n        _this.onPinch = function (event) {\n            var disabled = _this.setup.disabled;\n            var _a = _this.props, onPinching = _a.onPinching, onZoom = _a.onZoom;\n            if (disabled)\n                return;\n            var isAllowed = isPinchAllowed(_this);\n            if (!isAllowed)\n                return;\n            event.preventDefault();\n            event.stopPropagation();\n            handlePinchZoom(_this, event);\n            handleCallback(getContext(_this), event, onPinching);\n            handleCallback(getContext(_this), event, onZoom);\n        };\n        _this.onPinchStop = function (event) {\n            var _a = _this.props, onPinchingStop = _a.onPinchingStop, onZoomStop = _a.onZoomStop;\n            if (_this.pinchStartScale) {\n                handlePinchStop(_this);\n                handleCallback(getContext(_this), event, onPinchingStop);\n                handleCallback(getContext(_this), event, onZoomStop);\n            }\n        };\n        //////////\n        // Touch\n        //////////\n        _this.onTouchPanningStart = function (event) {\n            var disabled = _this.setup.disabled;\n            var onPanningStart = _this.props.onPanningStart;\n            if (disabled)\n                return;\n            var isAllowed = isPanningStartAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            var isDoubleTap = _this.lastTouch && +new Date() - _this.lastTouch < 200;\n            if (isDoubleTap && event.touches.length === 1) {\n                _this.onDoubleClick(event);\n            }\n            else {\n                _this.lastTouch = +new Date();\n                handleCancelAnimation(_this);\n                var touches = event.touches;\n                var isPanningAction = touches.length === 1;\n                var isPinchAction = touches.length === 2;\n                if (isPanningAction) {\n                    handleCancelAnimation(_this);\n                    handlePanningStart(_this, event);\n                    handleCallback(getContext(_this), event, onPanningStart);\n                }\n                if (isPinchAction) {\n                    _this.onPinchStart(event);\n                }\n            }\n        };\n        _this.onTouchPanning = function (event) {\n            var disabled = _this.setup.disabled;\n            var onPanning = _this.props.onPanning;\n            if (_this.isPanning && event.touches.length === 1) {\n                if (disabled)\n                    return;\n                var isAllowed = isPanningAllowed(_this);\n                if (!isAllowed)\n                    return;\n                event.preventDefault();\n                event.stopPropagation();\n                var touch = event.touches[0];\n                handlePanning(_this, touch.clientX, touch.clientY);\n                handleCallback(getContext(_this), event, onPanning);\n            }\n            else if (event.touches.length > 1) {\n                _this.onPinch(event);\n            }\n        };\n        _this.onTouchPanningStop = function (event) {\n            _this.onPanningStop(event);\n            _this.onPinchStop(event);\n        };\n        //////////\n        // Double Click\n        //////////\n        _this.onDoubleClick = function (event) {\n            var disabled = _this.setup.disabled;\n            if (disabled)\n                return;\n            var isAllowed = isDoubleClickAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            handleDoubleClick(_this, event);\n        };\n        //////////\n        // Helpers\n        //////////\n        _this.clearPanning = function (event) {\n            if (_this.isPanning) {\n                _this.onPanningStop(event);\n            }\n        };\n        _this.setKeyPressed = function (e) {\n            _this.pressedKeys[e.key] = true;\n        };\n        _this.setKeyUnPressed = function (e) {\n            _this.pressedKeys[e.key] = false;\n        };\n        _this.isPressingKeys = function (keys) {\n            if (!keys.length) {\n                return true;\n            }\n            return Boolean(keys.find(function (key) { return _this.pressedKeys[key]; }));\n        };\n        _this.setComponents = function (wrapperComponent, contentComponent) {\n            _this.wrapperComponent = wrapperComponent;\n            _this.contentComponent = contentComponent;\n            handleCalculateBounds(_this, _this.transformState.scale);\n            _this.handleInitializeWrapperEvents(wrapperComponent);\n            _this.handleInitialize();\n            _this.handleRef();\n            _this.isInitialized = true;\n            handleCallback(getContext(_this), undefined, _this.props.onInit);\n        };\n        _this.setTransformState = function (scale, positionX, positionY) {\n            if (!isNaN(scale) && !isNaN(positionX) && !isNaN(positionY)) {\n                if (scale !== _this.transformState.scale) {\n                    _this.transformState.previousScale = _this.transformState.scale;\n                    _this.transformState.scale = scale;\n                }\n                _this.transformState.positionX = positionX;\n                _this.transformState.positionY = positionY;\n                _this.applyTransformation();\n            }\n            else {\n                console.error(\"Detected NaN set state values\");\n            }\n        };\n        _this.setCenter = function () {\n            if (_this.wrapperComponent && _this.contentComponent) {\n                var targetState = getCenterPosition(_this.transformState.scale, _this.wrapperComponent, _this.contentComponent);\n                _this.setTransformState(targetState.scale, targetState.positionX, targetState.positionY);\n            }\n        };\n        _this.applyTransformation = function () {\n            if (!_this.mounted || !_this.contentComponent)\n                return;\n            var _a = _this.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n            var transform = getTransformStyles(positionX, positionY, scale);\n            _this.contentComponent.style.transform = transform;\n            _this.handleRef();\n        };\n        _this.handleRef = function () {\n            _this.props.setRef(getContext(_this));\n        };\n        return _this;\n    }\n    TransformContext.prototype.componentDidMount = function () {\n        var passive = makePassiveEventOption();\n        // Panning on window to allow panning when mouse is out of component wrapper\n        window.addEventListener(\"mousedown\", this.onPanningStart, passive);\n        window.addEventListener(\"mousemove\", this.onPanning, passive);\n        window.addEventListener(\"mouseup\", this.onPanningStop, passive);\n        document.addEventListener(\"mouseleave\", this.clearPanning, passive);\n        window.addEventListener(\"keyup\", this.setKeyUnPressed, passive);\n        window.addEventListener(\"keydown\", this.setKeyPressed, passive);\n        this.handleRef();\n    };\n    TransformContext.prototype.componentWillUnmount = function () {\n        var passive = makePassiveEventOption();\n        window.removeEventListener(\"mousedown\", this.onPanningStart, passive);\n        window.removeEventListener(\"mousemove\", this.onPanning, passive);\n        window.removeEventListener(\"mouseup\", this.onPanningStop, passive);\n        window.removeEventListener(\"keyup\", this.setKeyUnPressed, passive);\n        window.removeEventListener(\"keydown\", this.setKeyPressed, passive);\n        handleCancelAnimation(this);\n    };\n    TransformContext.prototype.componentDidUpdate = function (oldProps) {\n        if (oldProps !== this.props) {\n            handleCalculateBounds(this, this.transformState.scale);\n            this.setup = createSetup(this.props);\n        }\n    };\n    TransformContext.prototype.render = function () {\n        var value = getContext(this);\n        var children = this.props.children;\n        var content = typeof children === \"function\" ? children(value) : children;\n        return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Context.Provider, { value: __assign(__assign({}, this.transformState), { setComponents: this.setComponents, contextInstance: this }) }, content));\n    };\n    return TransformContext;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component));\n\nvar TransformWrapper = react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(function (props, ref) {\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), innerRef = _a[0], setRef = _a[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function () { return innerRef; }, [innerRef]);\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(TransformContext, __assign({}, props, { setRef: setRef }));\n});\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".transform-component-module_wrapper__1_Fgj {\\n  position: relative;\\n  width: -moz-fit-content;\\n  width: fit-content;\\n  height: -moz-fit-content;\\n  height: fit-content;\\n  overflow: hidden;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -khtml-user-select: none; /* Konqueror HTML */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n.transform-component-module_content__2jYgh {\\n  display: flex;\\n  flex-wrap: wrap;\\n  width: -moz-fit-content;\\n  width: fit-content;\\n  height: -moz-fit-content;\\n  height: fit-content;\\n  margin: 0;\\n  padding: 0;\\n  transform-origin: 0% 0%;\\n}\\n.transform-component-module_content__2jYgh img {\\n  pointer-events: none;\\n}\\n\";\nvar styles = {\"wrapper\":\"transform-component-module_wrapper__1_Fgj\",\"content\":\"transform-component-module_content__2jYgh\"};\nstyleInject(css_248z);\n\nvar TransformComponent = function (_a) {\n    var children = _a.children, _b = _a.wrapperClass, wrapperClass = _b === void 0 ? \"\" : _b, _c = _a.contentClass, contentClass = _c === void 0 ? \"\" : _c, wrapperStyle = _a.wrapperStyle, contentStyle = _a.contentStyle;\n    var setComponents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context).setComponents;\n    var wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var contentRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        var wrapper = wrapperRef.current;\n        var content = contentRef.current;\n        if (wrapper !== null && content !== null && setComponents) {\n            setComponents(wrapper, content);\n        }\n    }, []);\n    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: wrapperRef, className: \"react-transform-wrapper \" + styles.wrapper + \" \" + wrapperClass, style: wrapperStyle },\n        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: contentRef, className: \"react-transform-component \" + styles.content + \" \" + contentClass, style: contentStyle }, children)));\n};\n\nvar useTransformContext = function () {\n    var libraryContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    if (!libraryContext.contextInstance) {\n        throw new Error(\"Transform context mus be placed inside TransformWrapper\");\n    }\n    return getContext(libraryContext.contextInstance);\n};\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtem9vbS1wYW4tcGluY2gvZGlzdC9pbmRleC5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUc7O0FBRXZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1CQUFtQiw2QkFBNkIsbUJBQW1CLHlCQUF5QjtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUMsMkJBQTJCO0FBQzNCLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLDJDQUEyQztBQUMzQywyQkFBMkI7QUFDM0Isb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsNkNBQTZDO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYywwREFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdDQUFnQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFtQixxQkFBcUIsMkJBQTJCLDBCQUEwQiwwREFBMEQsR0FBRztBQUMxSztBQUNBO0FBQ0EsQ0FBQyxDQUFDLDRDQUFTOztBQUVYLHVCQUF1Qix1REFBZ0I7QUFDdkMsYUFBYSwrQ0FBUTtBQUNyQixJQUFJLDBEQUFtQixvQkFBb0Isa0JBQWtCO0FBQzdELFdBQVcsMERBQW1CLDhCQUE4QixXQUFXLGdCQUFnQjtBQUN2RixDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLDREQUE0RCx1QkFBdUIsNEJBQTRCLHVCQUF1Qiw2QkFBNkIsd0JBQXdCLHFCQUFxQixpQ0FBaUMsK0NBQStDLDBDQUEwQyxnREFBZ0Qsd0NBQXdDLGtEQUFrRCxjQUFjLGVBQWUsR0FBRyw4Q0FBOEMsa0JBQWtCLG9CQUFvQiw0QkFBNEIsdUJBQXVCLDZCQUE2Qix3QkFBd0IsY0FBYyxlQUFlLDRCQUE0QixHQUFHLGtEQUFrRCx5QkFBeUIsR0FBRztBQUMxekIsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQVU7QUFDbEMscUJBQXFCLDZDQUFNO0FBQzNCLHFCQUFxQiw2Q0FBTTtBQUMzQixJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLDBEQUFtQixVQUFVLG1IQUFtSDtBQUM1SixRQUFRLDBEQUFtQixVQUFVLHFIQUFxSDtBQUMxSjs7QUFFQTtBQUNBLHlCQUF5QixpREFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRTtBQUNyRSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbWludXNjbGllbnQvLi9ub2RlX21vZHVsZXMvcmVhY3Qtem9vbS1wYW4tcGluY2gvZGlzdC9pbmRleC5lc20uanM/YWFhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCB1c2VTdGF0ZSwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IGZyb20pO1xyXG59XG5cbi8qKlxuICogUm91bmRzIG51bWJlciB0byBnaXZlbiBkZWNpbWFsXG4gKiBlZy4gcm91bmROdW1iZXIoMi4zNDM0MywgMSkgPT4gMi4zXG4gKi9cbnZhciByb3VuZE51bWJlciA9IGZ1bmN0aW9uIChudW0sIGRlY2ltYWwpIHtcbiAgICByZXR1cm4gTnVtYmVyKG51bS50b0ZpeGVkKGRlY2ltYWwpKTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB2YWx1ZSBpcyBudW1iZXIsIGlmIG5vdCBpdCByZXR1cm5zIGRlZmF1bHQgdmFsdWVcbiAqIDEjIGVnLiBjaGVja0lzTnVtYmVyKDIsIDMwKSA9PiAyXG4gKiAyIyBlZy4gY2hlY2tJc051bWJlcihudWxsLCAzMCkgPT4gMzBcbiAqL1xudmFyIGNoZWNrSXNOdW1iZXIgPSBmdW5jdGlvbiAobnVtLCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gXCJudW1iZXJcIiA/IG51bSA6IGRlZmF1bHRWYWx1ZTtcbn07XG5cbnZhciBoYW5kbGVDYWxsYmFjayA9IGZ1bmN0aW9uIChjb250ZXh0LCBldmVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2soY29udGV4dCwgZXZlbnQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRnVuY3Rpb25zIHNob3VsZCByZXR1cm4gZGVub21pbmF0b3Igb2YgdGhlIHRhcmdldCB2YWx1ZSwgd2hpY2ggaXMgdGhlIG5leHQgYW5pbWF0aW9uIHN0ZXAuXG4gKiB0IGlzIGEgdmFsdWUgZnJvbSAwIHRvIDEsIHJlZmxlY3RpbmcgdGhlIHBlcmNlbnRhZ2Ugb2YgYW5pbWF0aW9uIHN0YXR1cy5cbiAqL1xudmFyIGVhc2VPdXQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiAtTWF0aC5jb3ModCAqIE1hdGguUEkpIC8gMiArIDAuNTtcbn07XG4vLyBsaW5lYXJcbnZhciBsaW5lYXIgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0O1xufTtcbi8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbnZhciBlYXNlSW5RdWFkID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG59O1xuLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbnZhciBlYXNlT3V0UXVhZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiAoMiAtIHQpO1xufTtcbi8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxudmFyIGVhc2VJbk91dFF1YWQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG59O1xuLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxudmFyIGVhc2VJbkN1YmljID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xufTtcbi8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG52YXIgZWFzZU91dEN1YmljID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xufTtcbi8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxudmFyIGVhc2VJbk91dEN1YmljID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XG59O1xuLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxudmFyIGVhc2VJblF1YXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbn07XG4vLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxudmFyIGVhc2VPdXRRdWFydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIDEgLSAtLXQgKiB0ICogdCAqIHQ7XG59O1xuLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG52YXIgZWFzZUluT3V0UXVhcnQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gOCAqIHQgKiB0ICogdCAqIHQgOiAxIC0gOCAqIC0tdCAqIHQgKiB0ICogdDtcbn07XG4vLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG52YXIgZWFzZUluUXVpbnQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbn07XG4vLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxudmFyIGVhc2VPdXRRdWludCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIDEgKyAtLXQgKiB0ICogdCAqIHQgKiB0O1xufTtcbi8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxudmFyIGVhc2VJbk91dFF1aW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAtLXQgKiB0ICogdCAqIHQgKiB0O1xufTtcbnZhciBhbmltYXRpb25zID0ge1xuICAgIGVhc2VPdXQ6IGVhc2VPdXQsXG4gICAgbGluZWFyOiBsaW5lYXIsXG4gICAgZWFzZUluUXVhZDogZWFzZUluUXVhZCxcbiAgICBlYXNlT3V0UXVhZDogZWFzZU91dFF1YWQsXG4gICAgZWFzZUluT3V0UXVhZDogZWFzZUluT3V0UXVhZCxcbiAgICBlYXNlSW5DdWJpYzogZWFzZUluQ3ViaWMsXG4gICAgZWFzZU91dEN1YmljOiBlYXNlT3V0Q3ViaWMsXG4gICAgZWFzZUluT3V0Q3ViaWM6IGVhc2VJbk91dEN1YmljLFxuICAgIGVhc2VJblF1YXJ0OiBlYXNlSW5RdWFydCxcbiAgICBlYXNlT3V0UXVhcnQ6IGVhc2VPdXRRdWFydCxcbiAgICBlYXNlSW5PdXRRdWFydDogZWFzZUluT3V0UXVhcnQsXG4gICAgZWFzZUluUXVpbnQ6IGVhc2VJblF1aW50LFxuICAgIGVhc2VPdXRRdWludDogZWFzZU91dFF1aW50LFxuICAgIGVhc2VJbk91dFF1aW50OiBlYXNlSW5PdXRRdWludCxcbn07XG5cbnZhciBoYW5kbGVDYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGFuaW1hdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb24pO1xuICAgIH1cbn07XG52YXIgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIGlmICghY29udGV4dEluc3RhbmNlLm1vdW50ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBoYW5kbGVDYW5jZWxBbmltYXRpb25GcmFtZShjb250ZXh0SW5zdGFuY2UuYW5pbWF0aW9uKTtcbiAgICAvLyBDbGVhciBhbmltYXRpb24gc3RhdGVcbiAgICBjb250ZXh0SW5zdGFuY2UuYW5pbWF0ZSA9IGZhbHNlO1xuICAgIGNvbnRleHRJbnN0YW5jZS5hbmltYXRpb24gPSBudWxsO1xuICAgIGNvbnRleHRJbnN0YW5jZS52ZWxvY2l0eSA9IG51bGw7XG59O1xuZnVuY3Rpb24gaGFuZGxlU2V0dXBBbmltYXRpb24oY29udGV4dEluc3RhbmNlLCBhbmltYXRpb25OYW1lLCBhbmltYXRpb25UaW1lLCBjYWxsYmFjaykge1xuICAgIGlmICghY29udGV4dEluc3RhbmNlLm1vdW50ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdmFyIGxhc3RTdGVwID0gMTtcbiAgICAvLyBpZiBhbm90aGVyIGFuaW1hdGlvbiBpcyBhY3RpdmVcbiAgICBoYW5kbGVDYW5jZWxBbmltYXRpb24oY29udGV4dEluc3RhbmNlKTtcbiAgICAvLyBuZXcgYW5pbWF0aW9uXG4gICAgY29udGV4dEluc3RhbmNlLmFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFjb250ZXh0SW5zdGFuY2UubW91bnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNhbmNlbEFuaW1hdGlvbkZyYW1lKGNvbnRleHRJbnN0YW5jZS5hbmltYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcmFtZVRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgdmFyIGFuaW1hdGlvblByb2dyZXNzID0gZnJhbWVUaW1lIC8gYW5pbWF0aW9uVGltZTtcbiAgICAgICAgdmFyIGFuaW1hdGlvblR5cGUgPSBhbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdO1xuICAgICAgICB2YXIgc3RlcCA9IGFuaW1hdGlvblR5cGUoYW5pbWF0aW9uUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAoZnJhbWVUaW1lID49IGFuaW1hdGlvblRpbWUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGxhc3RTdGVwKTtcbiAgICAgICAgICAgIGNvbnRleHRJbnN0YW5jZS5hbmltYXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRleHRJbnN0YW5jZS5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHN0ZXApO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNvbnRleHRJbnN0YW5jZS5hbmltYXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY29udGV4dEluc3RhbmNlLmFuaW1hdGlvbik7XG59XG5mdW5jdGlvbiBhbmltYXRlKGNvbnRleHRJbnN0YW5jZSwgdGFyZ2V0U3RhdGUsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvbk5hbWUpIHtcbiAgICB2YXIgaXNWYWxpZCA9IGlzVmFsaWRUYXJnZXRTdGF0ZSh0YXJnZXRTdGF0ZSk7XG4gICAgaWYgKCFjb250ZXh0SW5zdGFuY2UubW91bnRlZCB8fCAhaXNWYWxpZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBzZXRUcmFuc2Zvcm1TdGF0ZSA9IGNvbnRleHRJbnN0YW5jZS5zZXRUcmFuc2Zvcm1TdGF0ZTtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUsIHNjYWxlID0gX2Euc2NhbGUsIHBvc2l0aW9uWCA9IF9hLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gX2EucG9zaXRpb25ZO1xuICAgIHZhciBzY2FsZURpZmYgPSB0YXJnZXRTdGF0ZS5zY2FsZSAtIHNjYWxlO1xuICAgIHZhciBwb3NpdGlvblhEaWZmID0gdGFyZ2V0U3RhdGUucG9zaXRpb25YIC0gcG9zaXRpb25YO1xuICAgIHZhciBwb3NpdGlvbllEaWZmID0gdGFyZ2V0U3RhdGUucG9zaXRpb25ZIC0gcG9zaXRpb25ZO1xuICAgIGlmIChhbmltYXRpb25UaW1lID09PSAwKSB7XG4gICAgICAgIHNldFRyYW5zZm9ybVN0YXRlKHRhcmdldFN0YXRlLnNjYWxlLCB0YXJnZXRTdGF0ZS5wb3NpdGlvblgsIHRhcmdldFN0YXRlLnBvc2l0aW9uWSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhbmltYXRpb24gc3RhcnQgdGltZXN0YW1wXG4gICAgICAgIGhhbmRsZVNldHVwQW5pbWF0aW9uKGNvbnRleHRJbnN0YW5jZSwgYW5pbWF0aW9uTmFtZSwgYW5pbWF0aW9uVGltZSwgZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciBuZXdTY2FsZSA9IHNjYWxlICsgc2NhbGVEaWZmICogc3RlcDtcbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvblggPSBwb3NpdGlvblggKyBwb3NpdGlvblhEaWZmICogc3RlcDtcbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvblkgPSBwb3NpdGlvblkgKyBwb3NpdGlvbllEaWZmICogc3RlcDtcbiAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0YXRlKG5ld1NjYWxlLCBuZXdQb3NpdGlvblgsIG5ld1Bvc2l0aW9uWSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRUYXJnZXRTdGF0ZSh0YXJnZXRTdGF0ZSkge1xuICAgIHZhciBzY2FsZSA9IHRhcmdldFN0YXRlLnNjYWxlLCBwb3NpdGlvblggPSB0YXJnZXRTdGF0ZS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IHRhcmdldFN0YXRlLnBvc2l0aW9uWTtcbiAgICBpZiAoaXNOYU4oc2NhbGUpIHx8IGlzTmFOKHBvc2l0aW9uWCkgfHwgaXNOYU4ocG9zaXRpb25ZKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzU2l6ZXMod3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCwgbmV3U2NhbGUpIHtcbiAgICB2YXIgd3JhcHBlcldpZHRoID0gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRXaWR0aDtcbiAgICB2YXIgd3JhcHBlckhlaWdodCA9IHdyYXBwZXJDb21wb25lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHZhciBjb250ZW50V2lkdGggPSBjb250ZW50Q29tcG9uZW50Lm9mZnNldFdpZHRoO1xuICAgIHZhciBjb250ZW50SGVpZ2h0ID0gY29udGVudENvbXBvbmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIG5ld0NvbnRlbnRXaWR0aCA9IGNvbnRlbnRXaWR0aCAqIG5ld1NjYWxlO1xuICAgIHZhciBuZXdDb250ZW50SGVpZ2h0ID0gY29udGVudEhlaWdodCAqIG5ld1NjYWxlO1xuICAgIHZhciBuZXdEaWZmV2lkdGggPSB3cmFwcGVyV2lkdGggLSBuZXdDb250ZW50V2lkdGg7XG4gICAgdmFyIG5ld0RpZmZIZWlnaHQgPSB3cmFwcGVySGVpZ2h0IC0gbmV3Q29udGVudEhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgICB3cmFwcGVyV2lkdGg6IHdyYXBwZXJXaWR0aCxcbiAgICAgICAgd3JhcHBlckhlaWdodDogd3JhcHBlckhlaWdodCxcbiAgICAgICAgbmV3Q29udGVudFdpZHRoOiBuZXdDb250ZW50V2lkdGgsXG4gICAgICAgIG5ld0RpZmZXaWR0aDogbmV3RGlmZldpZHRoLFxuICAgICAgICBuZXdDb250ZW50SGVpZ2h0OiBuZXdDb250ZW50SGVpZ2h0LFxuICAgICAgICBuZXdEaWZmSGVpZ2h0OiBuZXdEaWZmSGVpZ2h0LFxuICAgIH07XG59XG52YXIgZ2V0Qm91bmRzID0gZnVuY3Rpb24gKHdyYXBwZXJXaWR0aCwgbmV3Q29udGVudFdpZHRoLCBkaWZmV2lkdGgsIHdyYXBwZXJIZWlnaHQsIG5ld0NvbnRlbnRIZWlnaHQsIGRpZmZIZWlnaHQsIGNlbnRlclpvb21lZE91dCkge1xuICAgIHZhciBzY2FsZVdpZHRoRmFjdG9yID0gd3JhcHBlcldpZHRoID4gbmV3Q29udGVudFdpZHRoXG4gICAgICAgID8gZGlmZldpZHRoICogKGNlbnRlclpvb21lZE91dCA/IDEgOiAwLjUpXG4gICAgICAgIDogMDtcbiAgICB2YXIgc2NhbGVIZWlnaHRGYWN0b3IgPSB3cmFwcGVySGVpZ2h0ID4gbmV3Q29udGVudEhlaWdodFxuICAgICAgICA/IGRpZmZIZWlnaHQgKiAoY2VudGVyWm9vbWVkT3V0ID8gMSA6IDAuNSlcbiAgICAgICAgOiAwO1xuICAgIHZhciBtaW5Qb3NpdGlvblggPSB3cmFwcGVyV2lkdGggLSBuZXdDb250ZW50V2lkdGggLSBzY2FsZVdpZHRoRmFjdG9yO1xuICAgIHZhciBtYXhQb3NpdGlvblggPSBzY2FsZVdpZHRoRmFjdG9yO1xuICAgIHZhciBtaW5Qb3NpdGlvblkgPSB3cmFwcGVySGVpZ2h0IC0gbmV3Q29udGVudEhlaWdodCAtIHNjYWxlSGVpZ2h0RmFjdG9yO1xuICAgIHZhciBtYXhQb3NpdGlvblkgPSBzY2FsZUhlaWdodEZhY3RvcjtcbiAgICByZXR1cm4geyBtaW5Qb3NpdGlvblg6IG1pblBvc2l0aW9uWCwgbWF4UG9zaXRpb25YOiBtYXhQb3NpdGlvblgsIG1pblBvc2l0aW9uWTogbWluUG9zaXRpb25ZLCBtYXhQb3NpdGlvblk6IG1heFBvc2l0aW9uWSB9O1xufTtcbnZhciBjYWxjdWxhdGVCb3VuZHMgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBuZXdTY2FsZSkge1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudDtcbiAgICB2YXIgY2VudGVyWm9vbWVkT3V0ID0gY29udGV4dEluc3RhbmNlLnNldHVwLmNlbnRlclpvb21lZE91dDtcbiAgICBpZiAoIXdyYXBwZXJDb21wb25lbnQgfHwgIWNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50cyBhcmUgbm90IG1vdW50ZWRcIik7XG4gICAgfVxuICAgIHZhciBfYSA9IGdldENvbXBvbmVudHNTaXplcyh3cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50LCBuZXdTY2FsZSksIHdyYXBwZXJXaWR0aCA9IF9hLndyYXBwZXJXaWR0aCwgd3JhcHBlckhlaWdodCA9IF9hLndyYXBwZXJIZWlnaHQsIG5ld0NvbnRlbnRXaWR0aCA9IF9hLm5ld0NvbnRlbnRXaWR0aCwgbmV3RGlmZldpZHRoID0gX2EubmV3RGlmZldpZHRoLCBuZXdDb250ZW50SGVpZ2h0ID0gX2EubmV3Q29udGVudEhlaWdodCwgbmV3RGlmZkhlaWdodCA9IF9hLm5ld0RpZmZIZWlnaHQ7XG4gICAgdmFyIGJvdW5kcyA9IGdldEJvdW5kcyh3cmFwcGVyV2lkdGgsIG5ld0NvbnRlbnRXaWR0aCwgbmV3RGlmZldpZHRoLCB3cmFwcGVySGVpZ2h0LCBuZXdDb250ZW50SGVpZ2h0LCBuZXdEaWZmSGVpZ2h0LCBCb29sZWFuKGNlbnRlclpvb21lZE91dCkpO1xuICAgIHJldHVybiBib3VuZHM7XG59O1xudmFyIGhhbmRsZUNhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIG5ld1NjYWxlKSB7XG4gICAgdmFyIGJvdW5kcyA9IGNhbGN1bGF0ZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIG5ld1NjYWxlKTtcbiAgICAvLyBTYXZlIGJvdW5kc1xuICAgIGNvbnRleHRJbnN0YW5jZS5ib3VuZHMgPSBib3VuZHM7XG4gICAgcmV0dXJuIGJvdW5kcztcbn07XG5mdW5jdGlvbiBnZXRNb3VzZUJvdW5kZWRQb3NpdGlvbihwb3NpdGlvblgsIHBvc2l0aW9uWSwgYm91bmRzLCBsaW1pdFRvQm91bmRzLCBwYWRkaW5nVmFsdWVYLCBwYWRkaW5nVmFsdWVZLCB3cmFwcGVyQ29tcG9uZW50KSB7XG4gICAgdmFyIG1pblBvc2l0aW9uWCA9IGJvdW5kcy5taW5Qb3NpdGlvblgsIG1pblBvc2l0aW9uWSA9IGJvdW5kcy5taW5Qb3NpdGlvblksIG1heFBvc2l0aW9uWCA9IGJvdW5kcy5tYXhQb3NpdGlvblgsIG1heFBvc2l0aW9uWSA9IGJvdW5kcy5tYXhQb3NpdGlvblk7XG4gICAgdmFyIHBhZGRpbmdYID0gMDtcbiAgICB2YXIgcGFkZGluZ1kgPSAwO1xuICAgIGlmICh3cmFwcGVyQ29tcG9uZW50KSB7XG4gICAgICAgIHBhZGRpbmdYID0gcGFkZGluZ1ZhbHVlWDtcbiAgICAgICAgcGFkZGluZ1kgPSBwYWRkaW5nVmFsdWVZO1xuICAgIH1cbiAgICB2YXIgeCA9IGJvdW5kTGltaXRlcihwb3NpdGlvblgsIG1pblBvc2l0aW9uWCAtIHBhZGRpbmdYLCBtYXhQb3NpdGlvblggKyBwYWRkaW5nWCwgbGltaXRUb0JvdW5kcyk7XG4gICAgdmFyIHkgPSBib3VuZExpbWl0ZXIocG9zaXRpb25ZLCBtaW5Qb3NpdGlvblkgLSBwYWRkaW5nWSwgbWF4UG9zaXRpb25ZICsgcGFkZGluZ1ksIGxpbWl0VG9Cb3VuZHMpO1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbn1cbi8qKlxuICogS2VlcHMgdmFsdWUgYmV0d2VlbiBnaXZlbiBib3VuZHMsIHVzZWQgZm9yIGxpbWl0aW5nIHZpZXcgdG8gZ2l2ZW4gYm91bmRhcmllc1xuICogMSMgZWcuIGJvdW5kTGltaXRlcigyLCAwLCAzLCB0cnVlKSA9PiAyXG4gKiAyIyBlZy4gYm91bmRMaW1pdGVyKDQsIDAsIDMsIHRydWUpID0+IDNcbiAqIDMjIGVnLiBib3VuZExpbWl0ZXIoLTIsIDAsIDMsIHRydWUpID0+IDBcbiAqIDQjIGVnLiBib3VuZExpbWl0ZXIoMTAsIDAsIDMsIGZhbHNlKSA9PiAxMFxuICovXG52YXIgYm91bmRMaW1pdGVyID0gZnVuY3Rpb24gKHZhbHVlLCBtaW5Cb3VuZCwgbWF4Qm91bmQsIGlzQWN0aXZlKSB7XG4gICAgaWYgKCFpc0FjdGl2ZSlcbiAgICAgICAgcmV0dXJuIHJvdW5kTnVtYmVyKHZhbHVlLCAyKTtcbiAgICBpZiAodmFsdWUgPCBtaW5Cb3VuZClcbiAgICAgICAgcmV0dXJuIHJvdW5kTnVtYmVyKG1pbkJvdW5kLCAyKTtcbiAgICBpZiAodmFsdWUgPiBtYXhCb3VuZClcbiAgICAgICAgcmV0dXJuIHJvdW5kTnVtYmVyKG1heEJvdW5kLCAyKTtcbiAgICByZXR1cm4gcm91bmROdW1iZXIodmFsdWUsIDIpO1xufTtcblxuZnVuY3Rpb24gaGFuZGxlQ2FsY3VsYXRlWm9vbVBvc2l0aW9ucyhjb250ZXh0SW5zdGFuY2UsIG1vdXNlWCwgbW91c2VZLCBuZXdTY2FsZSwgYm91bmRzLCBsaW1pdFRvQm91bmRzKSB7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCBzY2FsZSA9IF9hLnNjYWxlLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWTtcbiAgICB2YXIgc2NhbGVEaWZmZXJlbmNlID0gbmV3U2NhbGUgLSBzY2FsZTtcbiAgICBpZiAodHlwZW9mIG1vdXNlWCAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgbW91c2VZICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb3VzZSBYIGFuZCBZIHBvc2l0aW9uIHdlcmUgbm90IHByb3ZpZGVkIVwiKTtcbiAgICAgICAgcmV0dXJuIHsgeDogcG9zaXRpb25YLCB5OiBwb3NpdGlvblkgfTtcbiAgICB9XG4gICAgdmFyIGNhbGN1bGF0ZWRQb3NpdGlvblggPSBwb3NpdGlvblggLSBtb3VzZVggKiBzY2FsZURpZmZlcmVuY2U7XG4gICAgdmFyIGNhbGN1bGF0ZWRQb3NpdGlvblkgPSBwb3NpdGlvblkgLSBtb3VzZVkgKiBzY2FsZURpZmZlcmVuY2U7XG4gICAgLy8gZG8gbm90IGxpbWl0IHRvIGJvdW5kcyB3aGVuIHRoZXJlIGlzIHBhZGRpbmcgYW5pbWF0aW9uLFxuICAgIC8vIGl0IGNhdXNlcyBhbmltYXRpb24gc3RyYW5nZSBiZWhhdmlvdXJcbiAgICB2YXIgbmV3UG9zaXRpb25zID0gZ2V0TW91c2VCb3VuZGVkUG9zaXRpb24oY2FsY3VsYXRlZFBvc2l0aW9uWCwgY2FsY3VsYXRlZFBvc2l0aW9uWSwgYm91bmRzLCBsaW1pdFRvQm91bmRzLCAwLCAwLCBudWxsKTtcbiAgICByZXR1cm4gbmV3UG9zaXRpb25zO1xufVxuZnVuY3Rpb24gY2hlY2tab29tQm91bmRzKHpvb20sIG1pblNjYWxlLCBtYXhTY2FsZSwgem9vbVBhZGRpbmcsIGVuYWJsZVBhZGRpbmcpIHtcbiAgICB2YXIgc2NhbGVQYWRkaW5nID0gZW5hYmxlUGFkZGluZyA/IHpvb21QYWRkaW5nIDogMDtcbiAgICB2YXIgbWluU2NhbGVXaXRoUGFkZGluZyA9IG1pblNjYWxlIC0gc2NhbGVQYWRkaW5nO1xuICAgIGlmICghaXNOYU4obWF4U2NhbGUpICYmIHpvb20gPj0gbWF4U2NhbGUpXG4gICAgICAgIHJldHVybiBtYXhTY2FsZTtcbiAgICBpZiAoIWlzTmFOKG1pblNjYWxlKSAmJiB6b29tIDw9IG1pblNjYWxlV2l0aFBhZGRpbmcpXG4gICAgICAgIHJldHVybiBtaW5TY2FsZVdpdGhQYWRkaW5nO1xuICAgIHJldHVybiB6b29tO1xufVxuXG52YXIgaXNQYW5uaW5nU3RhcnRBbGxvd2VkID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgZXhjbHVkZWQgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAucGFubmluZy5leGNsdWRlZDtcbiAgICB2YXIgaXNJbml0aWFsaXplZCA9IGNvbnRleHRJbnN0YW5jZS5pc0luaXRpYWxpemVkLCB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgaXNXcmFwcGVyQ2hpbGQgPSB3cmFwcGVyQ29tcG9uZW50ID09PSBudWxsIHx8IHdyYXBwZXJDb21wb25lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdyYXBwZXJDb21wb25lbnQuY29udGFpbnModGFyZ2V0KTtcbiAgICB2YXIgaXNBbGxvd2VkID0gaXNJbml0aWFsaXplZCAmJiB0YXJnZXQgJiYgaXNXcmFwcGVyQ2hpbGQ7XG4gICAgaWYgKCFpc0FsbG93ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgaXNFeGNsdWRlZCA9IGlzRXhjbHVkZWROb2RlKHRhcmdldCwgZXhjbHVkZWQpO1xuICAgIGlmIChpc0V4Y2x1ZGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xudmFyIGlzUGFubmluZ0FsbG93ZWQgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgdmFyIGlzSW5pdGlhbGl6ZWQgPSBjb250ZXh0SW5zdGFuY2UuaXNJbml0aWFsaXplZCwgaXNQYW5uaW5nID0gY29udGV4dEluc3RhbmNlLmlzUGFubmluZywgc2V0dXAgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXA7XG4gICAgdmFyIGRpc2FibGVkID0gc2V0dXAucGFubmluZy5kaXNhYmxlZDtcbiAgICB2YXIgaXNBbGxvd2VkID0gaXNJbml0aWFsaXplZCAmJiBpc1Bhbm5pbmcgJiYgIWRpc2FibGVkO1xuICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xudmFyIGhhbmRsZVBhbm5pbmdTZXR1cCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWTtcbiAgICBjb250ZXh0SW5zdGFuY2UuaXNQYW5uaW5nID0gdHJ1ZTtcbiAgICAvLyBQYW5uaW5nIHdpdGggbW91c2VcbiAgICB2YXIgeCA9IGV2ZW50LmNsaWVudFg7XG4gICAgdmFyIHkgPSBldmVudC5jbGllbnRZO1xuICAgIGNvbnRleHRJbnN0YW5jZS5zdGFydENvb3JkcyA9IHsgeDogeCAtIHBvc2l0aW9uWCwgeTogeSAtIHBvc2l0aW9uWSB9O1xufTtcbnZhciBoYW5kbGVUb3VjaFBhbm5pbmdTZXR1cCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XG4gICAgY29udGV4dEluc3RhbmNlLmlzUGFubmluZyA9IHRydWU7XG4gICAgLy8gUGFubmluZyB3aXRoIHRvdWNoXG4gICAgdmFyIG9uZUZpbmdlclRvdWNoID0gdG91Y2hlcy5sZW5ndGggPT09IDE7XG4gICAgaWYgKG9uZUZpbmdlclRvdWNoKSB7XG4gICAgICAgIHZhciB4ID0gdG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICB2YXIgeSA9IHRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgY29udGV4dEluc3RhbmNlLnN0YXJ0Q29vcmRzID0geyB4OiB4IC0gcG9zaXRpb25YLCB5OiB5IC0gcG9zaXRpb25ZIH07XG4gICAgfVxufTtcbmZ1bmN0aW9uIGhhbmRsZVBhblRvQm91bmRzKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblksIHNjYWxlID0gX2Euc2NhbGU7XG4gICAgdmFyIF9iID0gY29udGV4dEluc3RhbmNlLnNldHVwLCBkaXNhYmxlZCA9IF9iLmRpc2FibGVkLCBsaW1pdFRvQm91bmRzID0gX2IubGltaXRUb0JvdW5kcywgY2VudGVyWm9vbWVkT3V0ID0gX2IuY2VudGVyWm9vbWVkT3V0O1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgaWYgKGRpc2FibGVkIHx8ICF3cmFwcGVyQ29tcG9uZW50IHx8ICFjb250ZXh0SW5zdGFuY2UuYm91bmRzKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIF9jID0gY29udGV4dEluc3RhbmNlLmJvdW5kcywgbWF4UG9zaXRpb25YID0gX2MubWF4UG9zaXRpb25YLCBtaW5Qb3NpdGlvblggPSBfYy5taW5Qb3NpdGlvblgsIG1heFBvc2l0aW9uWSA9IF9jLm1heFBvc2l0aW9uWSwgbWluUG9zaXRpb25ZID0gX2MubWluUG9zaXRpb25ZO1xuICAgIHZhciB4Q2hhbmdlZCA9IHBvc2l0aW9uWCA+IG1heFBvc2l0aW9uWCB8fCBwb3NpdGlvblggPCBtaW5Qb3NpdGlvblg7XG4gICAgdmFyIHlDaGFuZ2VkID0gcG9zaXRpb25ZID4gbWF4UG9zaXRpb25ZIHx8IHBvc2l0aW9uWSA8IG1pblBvc2l0aW9uWTtcbiAgICB2YXIgbW91c2VQb3NYID0gcG9zaXRpb25YID4gbWF4UG9zaXRpb25YXG4gICAgICAgID8gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRXaWR0aFxuICAgICAgICA6IGNvbnRleHRJbnN0YW5jZS5zZXR1cC5taW5Qb3NpdGlvblggfHwgMDtcbiAgICB2YXIgbW91c2VQb3NZID0gcG9zaXRpb25ZID4gbWF4UG9zaXRpb25ZXG4gICAgICAgID8gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRIZWlnaHRcbiAgICAgICAgOiBjb250ZXh0SW5zdGFuY2Uuc2V0dXAubWluUG9zaXRpb25ZIHx8IDA7XG4gICAgdmFyIF9kID0gaGFuZGxlQ2FsY3VsYXRlWm9vbVBvc2l0aW9ucyhjb250ZXh0SW5zdGFuY2UsIG1vdXNlUG9zWCwgbW91c2VQb3NZLCBzY2FsZSwgY29udGV4dEluc3RhbmNlLmJvdW5kcywgbGltaXRUb0JvdW5kcyB8fCBjZW50ZXJab29tZWRPdXQpLCB4ID0gX2QueCwgeSA9IF9kLnk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICBwb3NpdGlvblg6IHhDaGFuZ2VkID8geCA6IHBvc2l0aW9uWCxcbiAgICAgICAgcG9zaXRpb25ZOiB5Q2hhbmdlZCA/IHkgOiBwb3NpdGlvblksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5ld1Bvc2l0aW9uKGNvbnRleHRJbnN0YW5jZSwgbmV3UG9zaXRpb25YLCBuZXdQb3NpdGlvblksIHBhZGRpbmdWYWx1ZVgsIHBhZGRpbmdWYWx1ZVkpIHtcbiAgICB2YXIgbGltaXRUb0JvdW5kcyA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cC5saW1pdFRvQm91bmRzO1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIGJvdW5kcyA9IGNvbnRleHRJbnN0YW5jZS5ib3VuZHM7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCBzY2FsZSA9IF9hLnNjYWxlLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWTtcbiAgICB2YXIgaGFzUG9zaXRpb25YQ2hhbmdlZCA9IG5ld1Bvc2l0aW9uWCAhPT0gcG9zaXRpb25YO1xuICAgIHZhciBoYXNQb3NpdGlvbllDaGFuZ2VkID0gbmV3UG9zaXRpb25ZICE9PSBwb3NpdGlvblk7XG4gICAgdmFyIGhhc05ld1Bvc2l0aW9uID0gIWhhc1Bvc2l0aW9uWENoYW5nZWQgfHwgIWhhc1Bvc2l0aW9uWUNoYW5nZWQ7XG4gICAgaWYgKCF3cmFwcGVyQ29tcG9uZW50IHx8IGhhc05ld1Bvc2l0aW9uIHx8ICFib3VuZHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgX2IgPSBnZXRNb3VzZUJvdW5kZWRQb3NpdGlvbihuZXdQb3NpdGlvblgsIG5ld1Bvc2l0aW9uWSwgYm91bmRzLCBsaW1pdFRvQm91bmRzLCBwYWRkaW5nVmFsdWVYLCBwYWRkaW5nVmFsdWVZLCB3cmFwcGVyQ29tcG9uZW50KSwgeCA9IF9iLngsIHkgPSBfYi55O1xuICAgIGNvbnRleHRJbnN0YW5jZS5zZXRUcmFuc2Zvcm1TdGF0ZShzY2FsZSwgeCwgeSk7XG59XG52YXIgZ2V0UGFubmluZ0NsaWVudFBvc2l0aW9uID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgY2xpZW50WCwgY2xpZW50WSkge1xuICAgIHZhciBzdGFydENvb3JkcyA9IGNvbnRleHRJbnN0YW5jZS5zdGFydENvb3JkcywgdHJhbnNmb3JtU3RhdGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGU7XG4gICAgdmFyIHBhbm5pbmcgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAucGFubmluZztcbiAgICB2YXIgbG9ja0F4aXNYID0gcGFubmluZy5sb2NrQXhpc1gsIGxvY2tBeGlzWSA9IHBhbm5pbmcubG9ja0F4aXNZO1xuICAgIHZhciBwb3NpdGlvblggPSB0cmFuc2Zvcm1TdGF0ZS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IHRyYW5zZm9ybVN0YXRlLnBvc2l0aW9uWTtcbiAgICBpZiAoIXN0YXJ0Q29vcmRzKSB7XG4gICAgICAgIHJldHVybiB7IHg6IHBvc2l0aW9uWCwgeTogcG9zaXRpb25ZIH07XG4gICAgfVxuICAgIHZhciBtb3VzZVggPSBjbGllbnRYIC0gc3RhcnRDb29yZHMueDtcbiAgICB2YXIgbW91c2VZID0gY2xpZW50WSAtIHN0YXJ0Q29vcmRzLnk7XG4gICAgdmFyIG5ld1Bvc2l0aW9uWCA9IGxvY2tBeGlzWCA/IHBvc2l0aW9uWCA6IG1vdXNlWDtcbiAgICB2YXIgbmV3UG9zaXRpb25ZID0gbG9ja0F4aXNZID8gcG9zaXRpb25ZIDogbW91c2VZO1xuICAgIHJldHVybiB7IHg6IG5ld1Bvc2l0aW9uWCwgeTogbmV3UG9zaXRpb25ZIH07XG59O1xudmFyIGdldFBhZGRpbmdWYWx1ZSA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIHNpemUpIHtcbiAgICB2YXIgc2V0dXAgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIHRyYW5zZm9ybVN0YXRlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlO1xuICAgIHZhciBzY2FsZSA9IHRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciBtaW5TY2FsZSA9IHNldHVwLm1pblNjYWxlO1xuICAgIGlmIChzaXplID4gMCAmJiBzY2FsZSA+PSBtaW5TY2FsZSkge1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuXG52YXIgaXNWZWxvY2l0eUNhbGN1bGF0aW9uQWxsb3dlZCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICB2YXIgbW91bnRlZCA9IGNvbnRleHRJbnN0YW5jZS5tb3VudGVkO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgdmVsb2NpdHlBbmltYXRpb24gPSBfYS52ZWxvY2l0eUFuaW1hdGlvbjtcbiAgICB2YXIgc2NhbGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgdmFyIGRpc2FibGVkVmVsb2NpdHkgPSB2ZWxvY2l0eUFuaW1hdGlvbi5kaXNhYmxlZDtcbiAgICB2YXIgaXNBbGxvd2VkID0gIWRpc2FibGVkVmVsb2NpdHkgfHwgc2NhbGUgPiAxIHx8ICFkaXNhYmxlZCB8fCBtb3VudGVkO1xuICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xudmFyIGlzVmVsb2NpdHlBbGxvd2VkID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIHZhciBtb3VudGVkID0gY29udGV4dEluc3RhbmNlLm1vdW50ZWQsIHZlbG9jaXR5ID0gY29udGV4dEluc3RhbmNlLnZlbG9jaXR5LCBib3VuZHMgPSBjb250ZXh0SW5zdGFuY2UuYm91bmRzO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgdmVsb2NpdHlBbmltYXRpb24gPSBfYS52ZWxvY2l0eUFuaW1hdGlvbjtcbiAgICB2YXIgc2NhbGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgdmFyIGRpc2FibGVkVmVsb2NpdHkgPSB2ZWxvY2l0eUFuaW1hdGlvbi5kaXNhYmxlZDtcbiAgICB2YXIgaXNBbGxvd2VkID0gIWRpc2FibGVkVmVsb2NpdHkgfHwgc2NhbGUgPiAxIHx8ICFkaXNhYmxlZCB8fCBtb3VudGVkO1xuICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF2ZWxvY2l0eSB8fCAhYm91bmRzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHlNb3ZlVGltZShjb250ZXh0SW5zdGFuY2UsIHZlbG9jaXR5KSB7XG4gICAgdmFyIHZlbG9jaXR5QW5pbWF0aW9uID0gY29udGV4dEluc3RhbmNlLnNldHVwLnZlbG9jaXR5QW5pbWF0aW9uO1xuICAgIHZhciBlcXVhbFRvTW92ZSA9IHZlbG9jaXR5QW5pbWF0aW9uLmVxdWFsVG9Nb3ZlLCBhbmltYXRpb25UaW1lID0gdmVsb2NpdHlBbmltYXRpb24uYW5pbWF0aW9uVGltZSwgc2Vuc2l0aXZpdHkgPSB2ZWxvY2l0eUFuaW1hdGlvbi5zZW5zaXRpdml0eTtcbiAgICBpZiAoZXF1YWxUb01vdmUpIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvblRpbWUgKiB2ZWxvY2l0eSAqIHNlbnNpdGl2aXR5O1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9uVGltZTtcbn1cbmZ1bmN0aW9uIGdldFZlbG9jaXR5UG9zaXRpb24obmV3UG9zaXRpb24sIHN0YXJ0UG9zaXRpb24sIGN1cnJlbnRQb3NpdGlvbiwgaXNMb2NrZWQsIGxpbWl0VG9Cb3VuZHMsIG1pblBvc2l0aW9uLCBtYXhQb3NpdGlvbiwgbWluVGFyZ2V0LCBtYXhUYXJnZXQsIHN0ZXApIHtcbiAgICBpZiAobGltaXRUb0JvdW5kcykge1xuICAgICAgICBpZiAoc3RhcnRQb3NpdGlvbiA+IG1heFBvc2l0aW9uICYmIGN1cnJlbnRQb3NpdGlvbiA+IG1heFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZFBvc2l0aW9uID0gbWF4UG9zaXRpb24gKyAobmV3UG9zaXRpb24gLSBtYXhQb3NpdGlvbikgKiBzdGVwO1xuICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZWRQb3NpdGlvbiA+IG1heFRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4VGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZWRQb3NpdGlvbiA8IG1heFBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXhQb3NpdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPCBtaW5Qb3NpdGlvbiAmJiBjdXJyZW50UG9zaXRpb24gPCBtaW5Qb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZWRQb3NpdGlvbiA9IG1pblBvc2l0aW9uICsgKG5ld1Bvc2l0aW9uIC0gbWluUG9zaXRpb24pICogc3RlcDtcbiAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkUG9zaXRpb24gPCBtaW5UYXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pblRhcmdldDtcbiAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkUG9zaXRpb24gPiBtaW5Qb3NpdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gbWluUG9zaXRpb247XG4gICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0xvY2tlZClcbiAgICAgICAgcmV0dXJuIHN0YXJ0UG9zaXRpb247XG4gICAgcmV0dXJuIGJvdW5kTGltaXRlcihuZXdQb3NpdGlvbiwgbWluUG9zaXRpb24sIG1heFBvc2l0aW9uLCBsaW1pdFRvQm91bmRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZU11bHRpcGxpZXIod3JhcHBlckNvbXBvbmVudCwgZXF1YWxUb01vdmUpIHtcbiAgICB2YXIgZGVmYXVsdE11bHRpcGxpZXIgPSAxO1xuICAgIGlmIChlcXVhbFRvTW92ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oZGVmYXVsdE11bHRpcGxpZXIsIHdyYXBwZXJDb21wb25lbnQub2Zmc2V0V2lkdGggLyB3aW5kb3cuaW5uZXJXaWR0aCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0TXVsdGlwbGllcjtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNhbGN1bGF0ZVZlbG9jaXR5KGNvbnRleHRJbnN0YW5jZSwgcG9zaXRpb24pIHtcbiAgICB2YXIgaXNBbGxvd2VkID0gaXNWZWxvY2l0eUNhbGN1bGF0aW9uQWxsb3dlZChjb250ZXh0SW5zdGFuY2UpO1xuICAgIGlmICghaXNBbGxvd2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxhc3RNb3VzZVBvc2l0aW9uID0gY29udGV4dEluc3RhbmNlLmxhc3RNb3VzZVBvc2l0aW9uLCB2ZWxvY2l0eVRpbWUgPSBjb250ZXh0SW5zdGFuY2UudmVsb2NpdHlUaW1lLCBzZXR1cCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cDtcbiAgICB2YXIgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50O1xuICAgIHZhciBlcXVhbFRvTW92ZSA9IHNldHVwLnZlbG9jaXR5QW5pbWF0aW9uLmVxdWFsVG9Nb3ZlO1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChsYXN0TW91c2VQb3NpdGlvbiAmJiB2ZWxvY2l0eVRpbWUgJiYgd3JhcHBlckNvbXBvbmVudCkge1xuICAgICAgICB2YXIgc2l6ZU11bHRpcGxpZXIgPSBnZXRTaXplTXVsdGlwbGllcih3cmFwcGVyQ29tcG9uZW50LCBlcXVhbFRvTW92ZSk7XG4gICAgICAgIHZhciBkaXN0YW5jZVggPSBwb3NpdGlvbi54IC0gbGFzdE1vdXNlUG9zaXRpb24ueDtcbiAgICAgICAgdmFyIGRpc3RhbmNlWSA9IHBvc2l0aW9uLnkgLSBsYXN0TW91c2VQb3NpdGlvbi55O1xuICAgICAgICB2YXIgdmVsb2NpdHlYID0gZGlzdGFuY2VYIC8gc2l6ZU11bHRpcGxpZXI7XG4gICAgICAgIHZhciB2ZWxvY2l0eVkgPSBkaXN0YW5jZVkgLyBzaXplTXVsdGlwbGllcjtcbiAgICAgICAgdmFyIGludGVydmFsID0gbm93IC0gdmVsb2NpdHlUaW1lO1xuICAgICAgICB2YXIgc3BlZWQgPSBkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVk7XG4gICAgICAgIHZhciB2ZWxvY2l0eSA9IE1hdGguc3FydChzcGVlZCkgLyBpbnRlcnZhbDtcbiAgICAgICAgY29udGV4dEluc3RhbmNlLnZlbG9jaXR5ID0geyB2ZWxvY2l0eVg6IHZlbG9jaXR5WCwgdmVsb2NpdHlZOiB2ZWxvY2l0eVksIHRvdGFsOiB2ZWxvY2l0eSB9O1xuICAgIH1cbiAgICBjb250ZXh0SW5zdGFuY2UubGFzdE1vdXNlUG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICBjb250ZXh0SW5zdGFuY2UudmVsb2NpdHlUaW1lID0gbm93O1xufVxuZnVuY3Rpb24gaGFuZGxlVmVsb2NpdHlQYW5uaW5nKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIHZhciB2ZWxvY2l0eSA9IGNvbnRleHRJbnN0YW5jZS52ZWxvY2l0eSwgYm91bmRzID0gY29udGV4dEluc3RhbmNlLmJvdW5kcywgc2V0dXAgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIHdyYXBwZXJDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2Uud3JhcHBlckNvbXBvbmVudDtcbiAgICB2YXIgaXNBbGxvd2VkID0gaXNWZWxvY2l0eUFsbG93ZWQoY29udGV4dEluc3RhbmNlKTtcbiAgICBpZiAoIWlzQWxsb3dlZCB8fCAhdmVsb2NpdHkgfHwgIWJvdW5kcyB8fCAhd3JhcHBlckNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB2ZWxvY2l0eVggPSB2ZWxvY2l0eS52ZWxvY2l0eVgsIHZlbG9jaXR5WSA9IHZlbG9jaXR5LnZlbG9jaXR5WSwgdG90YWwgPSB2ZWxvY2l0eS50b3RhbDtcbiAgICB2YXIgbWF4UG9zaXRpb25YID0gYm91bmRzLm1heFBvc2l0aW9uWCwgbWluUG9zaXRpb25YID0gYm91bmRzLm1pblBvc2l0aW9uWCwgbWF4UG9zaXRpb25ZID0gYm91bmRzLm1heFBvc2l0aW9uWSwgbWluUG9zaXRpb25ZID0gYm91bmRzLm1pblBvc2l0aW9uWTtcbiAgICB2YXIgbGltaXRUb0JvdW5kcyA9IHNldHVwLmxpbWl0VG9Cb3VuZHMsIGFsaWdubWVudEFuaW1hdGlvbiA9IHNldHVwLmFsaWdubWVudEFuaW1hdGlvbjtcbiAgICB2YXIgem9vbUFuaW1hdGlvbiA9IHNldHVwLnpvb21BbmltYXRpb24sIHBhbm5pbmcgPSBzZXR1cC5wYW5uaW5nO1xuICAgIHZhciBsb2NrQXhpc1kgPSBwYW5uaW5nLmxvY2tBeGlzWSwgbG9ja0F4aXNYID0gcGFubmluZy5sb2NrQXhpc1g7XG4gICAgdmFyIGFuaW1hdGlvblR5cGUgPSB6b29tQW5pbWF0aW9uLmFuaW1hdGlvblR5cGU7XG4gICAgdmFyIHNpemVYID0gYWxpZ25tZW50QW5pbWF0aW9uLnNpemVYLCBzaXplWSA9IGFsaWdubWVudEFuaW1hdGlvbi5zaXplWSwgdmVsb2NpdHlBbGlnbm1lbnRUaW1lID0gYWxpZ25tZW50QW5pbWF0aW9uLnZlbG9jaXR5QWxpZ25tZW50VGltZTtcbiAgICB2YXIgYWxpZ25BbmltYXRpb25UaW1lID0gdmVsb2NpdHlBbGlnbm1lbnRUaW1lO1xuICAgIHZhciBtb3ZlQW5pbWF0aW9uVGltZSA9IGdldFZlbG9jaXR5TW92ZVRpbWUoY29udGV4dEluc3RhbmNlLCB0b3RhbCk7XG4gICAgdmFyIGZpbmFsQW5pbWF0aW9uVGltZSA9IE1hdGgubWF4KG1vdmVBbmltYXRpb25UaW1lLCBhbGlnbkFuaW1hdGlvblRpbWUpO1xuICAgIHZhciBwYWRkaW5nVmFsdWVYID0gZ2V0UGFkZGluZ1ZhbHVlKGNvbnRleHRJbnN0YW5jZSwgc2l6ZVgpO1xuICAgIHZhciBwYWRkaW5nVmFsdWVZID0gZ2V0UGFkZGluZ1ZhbHVlKGNvbnRleHRJbnN0YW5jZSwgc2l6ZVkpO1xuICAgIHZhciBwYWRkaW5nWCA9IChwYWRkaW5nVmFsdWVYICogd3JhcHBlckNvbXBvbmVudC5vZmZzZXRXaWR0aCkgLyAxMDA7XG4gICAgdmFyIHBhZGRpbmdZID0gKHBhZGRpbmdWYWx1ZVkgKiB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldEhlaWdodCkgLyAxMDA7XG4gICAgdmFyIG1heFRhcmdldFggPSBtYXhQb3NpdGlvblggKyBwYWRkaW5nWDtcbiAgICB2YXIgbWluVGFyZ2V0WCA9IG1pblBvc2l0aW9uWCAtIHBhZGRpbmdYO1xuICAgIHZhciBtYXhUYXJnZXRZID0gbWF4UG9zaXRpb25ZICsgcGFkZGluZ1k7XG4gICAgdmFyIG1pblRhcmdldFkgPSBtaW5Qb3NpdGlvblkgLSBwYWRkaW5nWTtcbiAgICB2YXIgc3RhcnRTdGF0ZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZTtcbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaGFuZGxlU2V0dXBBbmltYXRpb24oY29udGV4dEluc3RhbmNlLCBhbmltYXRpb25UeXBlLCBmaW5hbEFuaW1hdGlvblRpbWUsIGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XG4gICAgICAgIHZhciBmcmFtZVRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgdmFyIGFuaW1hdGlvblByb2dyZXNzID0gZnJhbWVUaW1lIC8gYWxpZ25BbmltYXRpb25UaW1lO1xuICAgICAgICB2YXIgYWxpZ25BbmltYXRpb24gPSBhbmltYXRpb25zW2FsaWdubWVudEFuaW1hdGlvbi5hbmltYXRpb25UeXBlXTtcbiAgICAgICAgdmFyIGFsaWduU3RlcCA9IDEgLSBhbGlnbkFuaW1hdGlvbihNYXRoLm1pbigxLCBhbmltYXRpb25Qcm9ncmVzcykpO1xuICAgICAgICB2YXIgY3VzdG9tU3RlcCA9IDEgLSBzdGVwO1xuICAgICAgICB2YXIgbmV3UG9zaXRpb25YID0gcG9zaXRpb25YICsgdmVsb2NpdHlYICogY3VzdG9tU3RlcDtcbiAgICAgICAgdmFyIG5ld1Bvc2l0aW9uWSA9IHBvc2l0aW9uWSArIHZlbG9jaXR5WSAqIGN1c3RvbVN0ZXA7XG4gICAgICAgIHZhciBjdXJyZW50UG9zaXRpb25YID0gZ2V0VmVsb2NpdHlQb3NpdGlvbihuZXdQb3NpdGlvblgsIHN0YXJ0U3RhdGUucG9zaXRpb25YLCBwb3NpdGlvblgsIGxvY2tBeGlzWCwgbGltaXRUb0JvdW5kcywgbWluUG9zaXRpb25YLCBtYXhQb3NpdGlvblgsIG1pblRhcmdldFgsIG1heFRhcmdldFgsIGFsaWduU3RlcCk7XG4gICAgICAgIHZhciBjdXJyZW50UG9zaXRpb25ZID0gZ2V0VmVsb2NpdHlQb3NpdGlvbihuZXdQb3NpdGlvblksIHN0YXJ0U3RhdGUucG9zaXRpb25ZLCBwb3NpdGlvblksIGxvY2tBeGlzWSwgbGltaXRUb0JvdW5kcywgbWluUG9zaXRpb25ZLCBtYXhQb3NpdGlvblksIG1pblRhcmdldFksIG1heFRhcmdldFksIGFsaWduU3RlcCk7XG4gICAgICAgIGlmIChwb3NpdGlvblggIT09IG5ld1Bvc2l0aW9uWCB8fCBwb3NpdGlvblkgIT09IG5ld1Bvc2l0aW9uWSkge1xuICAgICAgICAgICAgY29udGV4dEluc3RhbmNlLnNldFRyYW5zZm9ybVN0YXRlKHNjYWxlLCBjdXJyZW50UG9zaXRpb25YLCBjdXJyZW50UG9zaXRpb25ZKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVQYW5uaW5nU3RhcnQoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBzY2FsZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICBoYW5kbGVDYW5jZWxBbmltYXRpb24oY29udGV4dEluc3RhbmNlKTtcbiAgICBoYW5kbGVDYWxjdWxhdGVCb3VuZHMoY29udGV4dEluc3RhbmNlLCBzY2FsZSk7XG4gICAgaWYgKGV2ZW50LnRvdWNoZXMpIHtcbiAgICAgICAgaGFuZGxlVG91Y2hQYW5uaW5nU2V0dXAoY29udGV4dEluc3RhbmNlLCBldmVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoYW5kbGVQYW5uaW5nU2V0dXAoY29udGV4dEluc3RhbmNlLCBldmVudCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlUGFubmluZyhjb250ZXh0SW5zdGFuY2UsIGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICB2YXIgc3RhcnRDb29yZHMgPSBjb250ZXh0SW5zdGFuY2Uuc3RhcnRDb29yZHMsIHNldHVwID0gY29udGV4dEluc3RhbmNlLnNldHVwO1xuICAgIHZhciBfYSA9IHNldHVwLmFsaWdubWVudEFuaW1hdGlvbiwgc2l6ZVggPSBfYS5zaXplWCwgc2l6ZVkgPSBfYS5zaXplWTtcbiAgICBpZiAoIXN0YXJ0Q29vcmRzKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIF9iID0gZ2V0UGFubmluZ0NsaWVudFBvc2l0aW9uKGNvbnRleHRJbnN0YW5jZSwgY2xpZW50WCwgY2xpZW50WSksIHggPSBfYi54LCB5ID0gX2IueTtcbiAgICB2YXIgcGFkZGluZ1ZhbHVlWCA9IGdldFBhZGRpbmdWYWx1ZShjb250ZXh0SW5zdGFuY2UsIHNpemVYKTtcbiAgICB2YXIgcGFkZGluZ1ZhbHVlWSA9IGdldFBhZGRpbmdWYWx1ZShjb250ZXh0SW5zdGFuY2UsIHNpemVZKTtcbiAgICBoYW5kbGVDYWxjdWxhdGVWZWxvY2l0eShjb250ZXh0SW5zdGFuY2UsIHsgeDogeCwgeTogeSB9KTtcbiAgICBoYW5kbGVOZXdQb3NpdGlvbihjb250ZXh0SW5zdGFuY2UsIHgsIHksIHBhZGRpbmdWYWx1ZVgsIHBhZGRpbmdWYWx1ZVkpO1xufVxuZnVuY3Rpb24gaGFuZGxlUGFubmluZ0VuZChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICBpZiAoY29udGV4dEluc3RhbmNlLmlzUGFubmluZykge1xuICAgICAgICB2YXIgdmVsb2NpdHlEaXNhYmxlZCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cC5wYW5uaW5nLnZlbG9jaXR5RGlzYWJsZWQ7XG4gICAgICAgIHZhciB2ZWxvY2l0eSA9IGNvbnRleHRJbnN0YW5jZS52ZWxvY2l0eSwgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLmNvbnRlbnRDb21wb25lbnQ7XG4gICAgICAgIGNvbnRleHRJbnN0YW5jZS5pc1Bhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgY29udGV4dEluc3RhbmNlLmFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgY29udGV4dEluc3RhbmNlLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciB3cmFwcGVyUmVjdCA9IHdyYXBwZXJDb21wb25lbnQgPT09IG51bGwgfHwgd3JhcHBlckNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd3JhcHBlckNvbXBvbmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGNvbnRlbnRSZWN0ID0gY29udGVudENvbXBvbmVudCA9PT0gbnVsbCB8fCBjb250ZW50Q29tcG9uZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZW50Q29tcG9uZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgd3JhcHBlcldpZHRoID0gKHdyYXBwZXJSZWN0ID09PSBudWxsIHx8IHdyYXBwZXJSZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3cmFwcGVyUmVjdC53aWR0aCkgfHwgMDtcbiAgICAgICAgdmFyIHdyYXBwZXJIZWlnaHQgPSAod3JhcHBlclJlY3QgPT09IG51bGwgfHwgd3JhcHBlclJlY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdyYXBwZXJSZWN0LmhlaWdodCkgfHwgMDtcbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IChjb250ZW50UmVjdCA9PT0gbnVsbCB8fCBjb250ZW50UmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGVudFJlY3Qud2lkdGgpIHx8IDA7XG4gICAgICAgIHZhciBjb250ZW50SGVpZ2h0ID0gKGNvbnRlbnRSZWN0ID09PSBudWxsIHx8IGNvbnRlbnRSZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZW50UmVjdC5oZWlnaHQpIHx8IDA7XG4gICAgICAgIHZhciBpc1pvb21lZCA9IHdyYXBwZXJXaWR0aCA8IGNvbnRlbnRXaWR0aCB8fCB3cmFwcGVySGVpZ2h0IDwgY29udGVudEhlaWdodDtcbiAgICAgICAgdmFyIHNob3VsZEFuaW1hdGUgPSAhdmVsb2NpdHlEaXNhYmxlZCAmJiB2ZWxvY2l0eSAmJiAodmVsb2NpdHkgPT09IG51bGwgfHwgdmVsb2NpdHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZlbG9jaXR5LnRvdGFsKSA+IDAuMSAmJiBpc1pvb21lZDtcbiAgICAgICAgaWYgKHNob3VsZEFuaW1hdGUpIHtcbiAgICAgICAgICAgIGhhbmRsZVZlbG9jaXR5UGFubmluZyhjb250ZXh0SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlQWxpZ25Ub0JvdW5kcyhjb250ZXh0SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQWxpZ25Ub0JvdW5kcyhjb250ZXh0SW5zdGFuY2UpIHtcbiAgICB2YXIgc2NhbGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnNldHVwLCBtaW5TY2FsZSA9IF9hLm1pblNjYWxlLCBhbGlnbm1lbnRBbmltYXRpb24gPSBfYS5hbGlnbm1lbnRBbmltYXRpb247XG4gICAgdmFyIGRpc2FibGVkID0gYWxpZ25tZW50QW5pbWF0aW9uLmRpc2FibGVkLCBzaXplWCA9IGFsaWdubWVudEFuaW1hdGlvbi5zaXplWCwgc2l6ZVkgPSBhbGlnbm1lbnRBbmltYXRpb24uc2l6ZVksIGFuaW1hdGlvblRpbWUgPSBhbGlnbm1lbnRBbmltYXRpb24uYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSA9IGFsaWdubWVudEFuaW1hdGlvbi5hbmltYXRpb25UeXBlO1xuICAgIHZhciBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgc2NhbGUgPCBtaW5TY2FsZSB8fCAoIXNpemVYICYmICFzaXplWSk7XG4gICAgaWYgKGlzRGlzYWJsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgdGFyZ2V0U3RhdGUgPSBoYW5kbGVQYW5Ub0JvdW5kcyhjb250ZXh0SW5zdGFuY2UpO1xuICAgIGlmICh0YXJnZXRTdGF0ZSkge1xuICAgICAgICBhbmltYXRlKGNvbnRleHRJbnN0YW5jZSwgdGFyZ2V0U3RhdGUsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQWxpZ25Ub1NjYWxlQm91bmRzKGNvbnRleHRJbnN0YW5jZSwgbW91c2VQb3NpdGlvblgsIG1vdXNlUG9zaXRpb25ZKSB7XG4gICAgdmFyIHNjYWxlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnNldHVwLCBtaW5TY2FsZSA9IF9hLm1pblNjYWxlLCBsaW1pdFRvQm91bmRzID0gX2EubGltaXRUb0JvdW5kcywgem9vbUFuaW1hdGlvbiA9IF9hLnpvb21BbmltYXRpb247XG4gICAgdmFyIGRpc2FibGVkID0gem9vbUFuaW1hdGlvbi5kaXNhYmxlZCwgYW5pbWF0aW9uVGltZSA9IHpvb21BbmltYXRpb24uYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSA9IHpvb21BbmltYXRpb24uYW5pbWF0aW9uVHlwZTtcbiAgICB2YXIgaXNEaXNhYmxlZCA9IGRpc2FibGVkIHx8IHNjYWxlID49IG1pblNjYWxlO1xuICAgIGlmIChzY2FsZSA+PSAxIHx8IGxpbWl0VG9Cb3VuZHMpIHtcbiAgICAgICAgLy8gZmlyZSBmaXQgdG8gYm91bmRzIGFuaW1hdGlvblxuICAgICAgICBoYW5kbGVBbGlnblRvQm91bmRzKGNvbnRleHRJbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChpc0Rpc2FibGVkIHx8ICF3cmFwcGVyQ29tcG9uZW50IHx8ICFjb250ZXh0SW5zdGFuY2UubW91bnRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBtb3VzZVggPSBtb3VzZVBvc2l0aW9uWCB8fCB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldFdpZHRoIC8gMjtcbiAgICB2YXIgbW91c2VZID0gbW91c2VQb3NpdGlvblkgfHwgd3JhcHBlckNvbXBvbmVudC5vZmZzZXRIZWlnaHQgLyAyO1xuICAgIHZhciB0YXJnZXRTdGF0ZSA9IGhhbmRsZVpvb21Ub1BvaW50KGNvbnRleHRJbnN0YW5jZSwgbWluU2NhbGUsIG1vdXNlWCwgbW91c2VZKTtcbiAgICBpZiAodGFyZ2V0U3RhdGUpIHtcbiAgICAgICAgYW5pbWF0ZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldFN0YXRlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVab29tVG9Qb2ludChjb250ZXh0SW5zdGFuY2UsIHNjYWxlLCBtb3VzZVgsIG1vdXNlWSkge1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgbWluU2NhbGUgPSBfYS5taW5TY2FsZSwgbWF4U2NhbGUgPSBfYS5tYXhTY2FsZSwgbGltaXRUb0JvdW5kcyA9IF9hLmxpbWl0VG9Cb3VuZHM7XG4gICAgdmFyIG5ld1NjYWxlID0gY2hlY2tab29tQm91bmRzKHJvdW5kTnVtYmVyKHNjYWxlLCAyKSwgbWluU2NhbGUsIG1heFNjYWxlLCAwLCBmYWxzZSk7XG4gICAgdmFyIGJvdW5kcyA9IGhhbmRsZUNhbGN1bGF0ZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIG5ld1NjYWxlKTtcbiAgICB2YXIgX2IgPSBoYW5kbGVDYWxjdWxhdGVab29tUG9zaXRpb25zKGNvbnRleHRJbnN0YW5jZSwgbW91c2VYLCBtb3VzZVksIG5ld1NjYWxlLCBib3VuZHMsIGxpbWl0VG9Cb3VuZHMpLCB4ID0gX2IueCwgeSA9IF9iLnk7XG4gICAgcmV0dXJuIHsgc2NhbGU6IG5ld1NjYWxlLCBwb3NpdGlvblg6IHgsIHBvc2l0aW9uWTogeSB9O1xufVxuXG52YXIgaW5pdGlhbFN0YXRlID0ge1xuICAgIHByZXZpb3VzU2NhbGU6IDEsXG4gICAgc2NhbGU6IDEsXG4gICAgcG9zaXRpb25YOiAwLFxuICAgIHBvc2l0aW9uWTogMCxcbn07XG52YXIgY29udGV4dEluaXRpYWxTdGF0ZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpLCB7IHNldENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSwgY29udGV4dEluc3RhbmNlOiBudWxsIH0pO1xudmFyIGluaXRpYWxTZXR1cCA9IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgbWluUG9zaXRpb25YOiBudWxsLFxuICAgIG1heFBvc2l0aW9uWDogbnVsbCxcbiAgICBtaW5Qb3NpdGlvblk6IG51bGwsXG4gICAgbWF4UG9zaXRpb25ZOiBudWxsLFxuICAgIG1pblNjYWxlOiAxLFxuICAgIG1heFNjYWxlOiA4LFxuICAgIGxpbWl0VG9Cb3VuZHM6IHRydWUsXG4gICAgY2VudGVyWm9vbWVkT3V0OiBmYWxzZSxcbiAgICBjZW50ZXJPbkluaXQ6IGZhbHNlLFxuICAgIHdoZWVsOiB7XG4gICAgICAgIHN0ZXA6IDAuMixcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICB3aGVlbERpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgdG91Y2hQYWREaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIGFjdGl2YXRpb25LZXlzOiBbXSxcbiAgICAgICAgZXhjbHVkZWQ6IFtdLFxuICAgIH0sXG4gICAgcGFubmluZzoge1xuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIHZlbG9jaXR5RGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBsb2NrQXhpc1g6IGZhbHNlLFxuICAgICAgICBsb2NrQXhpc1k6IGZhbHNlLFxuICAgICAgICBhY3RpdmF0aW9uS2V5czogW10sXG4gICAgICAgIGV4Y2x1ZGVkOiBbXSxcbiAgICB9LFxuICAgIHBpbmNoOiB7XG4gICAgICAgIHN0ZXA6IDUsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgZXhjbHVkZWQ6IFtdLFxuICAgIH0sXG4gICAgZG91YmxlQ2xpY2s6IHtcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzdGVwOiAwLjcsXG4gICAgICAgIG1vZGU6IFwiem9vbUluXCIsXG4gICAgICAgIGFuaW1hdGlvblR5cGU6IFwiZWFzZU91dFwiLFxuICAgICAgICBhbmltYXRpb25UaW1lOiAyMDAsXG4gICAgICAgIGV4Y2x1ZGVkOiBbXSxcbiAgICB9LFxuICAgIHpvb21BbmltYXRpb246IHtcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzaXplOiAwLjQsXG4gICAgICAgIGFuaW1hdGlvblRpbWU6IDIwMCxcbiAgICAgICAgYW5pbWF0aW9uVHlwZTogXCJlYXNlT3V0XCIsXG4gICAgfSxcbiAgICBhbGlnbm1lbnRBbmltYXRpb246IHtcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzaXplWDogMTAwLFxuICAgICAgICBzaXplWTogMTAwLFxuICAgICAgICBhbmltYXRpb25UaW1lOiAyMDAsXG4gICAgICAgIHZlbG9jaXR5QWxpZ25tZW50VGltZTogNDAwLFxuICAgICAgICBhbmltYXRpb25UeXBlOiBcImVhc2VPdXRcIixcbiAgICB9LFxuICAgIHZlbG9jaXR5QW5pbWF0aW9uOiB7XG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgc2Vuc2l0aXZpdHk6IDEsXG4gICAgICAgIGFuaW1hdGlvblRpbWU6IDQwMCxcbiAgICAgICAgYW5pbWF0aW9uVHlwZTogXCJlYXNlT3V0XCIsXG4gICAgICAgIGVxdWFsVG9Nb3ZlOiB0cnVlLFxuICAgIH0sXG59O1xuXG52YXIgY3JlYXRlU3RhdGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJldmlvdXNTY2FsZTogKF9hID0gcHJvcHMuaW5pdGlhbFNjYWxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpbml0aWFsU3RhdGUuc2NhbGUsXG4gICAgICAgIHNjYWxlOiAoX2IgPSBwcm9wcy5pbml0aWFsU2NhbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGluaXRpYWxTdGF0ZS5zY2FsZSxcbiAgICAgICAgcG9zaXRpb25YOiAoX2MgPSBwcm9wcy5pbml0aWFsUG9zaXRpb25YKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBpbml0aWFsU3RhdGUucG9zaXRpb25YLFxuICAgICAgICBwb3NpdGlvblk6IChfZCA9IHByb3BzLmluaXRpYWxQb3NpdGlvblkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGluaXRpYWxTdGF0ZS5wb3NpdGlvblksXG4gICAgfTtcbn07XG52YXIgY3JlYXRlU2V0dXAgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgbmV3U2V0dXAgPSBfX2Fzc2lnbih7fSwgaW5pdGlhbFNldHVwKTtcbiAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWxpZFZhbHVlID0gdHlwZW9mIHByb3BzW2tleV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICAgIHZhciB2YWxpZFBhcmFtZXRlciA9IHR5cGVvZiBpbml0aWFsU2V0dXBba2V5XSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgaWYgKHZhbGlkUGFyYW1ldGVyICYmIHZhbGlkVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhVHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbml0aWFsU2V0dXBba2V5XSk7XG4gICAgICAgICAgICB2YXIgaXNPYmplY3QgPSBkYXRhVHlwZSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgICAgICAgICAgIHZhciBpc0FycmF5ID0gZGF0YVR5cGUgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgICAgICAgIGlmIChpc09iamVjdCkge1xuICAgICAgICAgICAgICAgIG5ld1NldHVwW2tleV0gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5pdGlhbFNldHVwW2tleV0pLCBwcm9wc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBuZXdTZXR1cFtrZXldID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBpbml0aWFsU2V0dXBba2V5XSksIHByb3BzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2V0dXBba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3U2V0dXA7XG59O1xuXG52YXIgaGFuZGxlQ2FsY3VsYXRlQnV0dG9uWm9vbSA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGRlbHRhLCBzdGVwKSB7XG4gICAgdmFyIHNjYWxlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIHNldHVwID0gY29udGV4dEluc3RhbmNlLnNldHVwO1xuICAgIHZhciBtYXhTY2FsZSA9IHNldHVwLm1heFNjYWxlLCBtaW5TY2FsZSA9IHNldHVwLm1pblNjYWxlLCB6b29tQW5pbWF0aW9uID0gc2V0dXAuem9vbUFuaW1hdGlvbjtcbiAgICB2YXIgc2l6ZSA9IHpvb21BbmltYXRpb24uc2l6ZTtcbiAgICBpZiAoIXdyYXBwZXJDb21wb25lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JhcHBlciBpcyBub3QgbW91bnRlZFwiKTtcbiAgICB9XG4gICAgdmFyIHRhcmdldFNjYWxlID0gc2NhbGUgKiBNYXRoLmV4cChkZWx0YSAqIHN0ZXApO1xuICAgIHZhciBuZXdTY2FsZSA9IGNoZWNrWm9vbUJvdW5kcyhyb3VuZE51bWJlcih0YXJnZXRTY2FsZSwgMyksIG1pblNjYWxlLCBtYXhTY2FsZSwgc2l6ZSwgZmFsc2UpO1xuICAgIHJldHVybiBuZXdTY2FsZTtcbn07XG5mdW5jdGlvbiBoYW5kbGVab29tVG9WaWV3Q2VudGVyKGNvbnRleHRJbnN0YW5jZSwgZGVsdGEsIHN0ZXAsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpIHtcbiAgICB2YXIgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50O1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XG4gICAgaWYgKCF3cmFwcGVyQ29tcG9uZW50KVxuICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIk5vIFdyYXBwZXJDb21wb25lbnQgZm91bmRcIik7XG4gICAgdmFyIHdyYXBwZXJXaWR0aCA9IHdyYXBwZXJDb21wb25lbnQub2Zmc2V0V2lkdGg7XG4gICAgdmFyIHdyYXBwZXJIZWlnaHQgPSB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldEhlaWdodDtcbiAgICB2YXIgbW91c2VYID0gKHdyYXBwZXJXaWR0aCAvIDIgLSBwb3NpdGlvblgpIC8gc2NhbGU7XG4gICAgdmFyIG1vdXNlWSA9ICh3cmFwcGVySGVpZ2h0IC8gMiAtIHBvc2l0aW9uWSkgLyBzY2FsZTtcbiAgICB2YXIgbmV3U2NhbGUgPSBoYW5kbGVDYWxjdWxhdGVCdXR0b25ab29tKGNvbnRleHRJbnN0YW5jZSwgZGVsdGEsIHN0ZXApO1xuICAgIHZhciB0YXJnZXRTdGF0ZSA9IGhhbmRsZVpvb21Ub1BvaW50KGNvbnRleHRJbnN0YW5jZSwgbmV3U2NhbGUsIG1vdXNlWCwgbW91c2VZKTtcbiAgICBpZiAoIXRhcmdldFN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIHpvb20gZXZlbnQuIE5ldyB0cmFuc2Zvcm1hdGlvbiBzdGF0ZSB3YXMgbm90IGNhbGN1bGF0ZWQuXCIpO1xuICAgIH1cbiAgICBhbmltYXRlKGNvbnRleHRJbnN0YW5jZSwgdGFyZ2V0U3RhdGUsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFuc2Zvcm1hdGlvbnMoY29udGV4dEluc3RhbmNlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKSB7XG4gICAgdmFyIHNldHVwID0gY29udGV4dEluc3RhbmNlLnNldHVwLCB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgdmFyIGxpbWl0VG9Cb3VuZHMgPSBzZXR1cC5saW1pdFRvQm91bmRzO1xuICAgIHZhciBpbml0aWFsVHJhbnNmb3JtYXRpb24gPSBjcmVhdGVTdGF0ZShjb250ZXh0SW5zdGFuY2UucHJvcHMpO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XG4gICAgaWYgKCF3cmFwcGVyQ29tcG9uZW50KVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIG5ld0JvdW5kcyA9IGNhbGN1bGF0ZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIGluaXRpYWxUcmFuc2Zvcm1hdGlvbi5zY2FsZSk7XG4gICAgdmFyIGJvdW5kZWRQb3NpdGlvbnMgPSBnZXRNb3VzZUJvdW5kZWRQb3NpdGlvbihpbml0aWFsVHJhbnNmb3JtYXRpb24ucG9zaXRpb25YLCBpbml0aWFsVHJhbnNmb3JtYXRpb24ucG9zaXRpb25ZLCBuZXdCb3VuZHMsIGxpbWl0VG9Cb3VuZHMsIDAsIDAsIHdyYXBwZXJDb21wb25lbnQpO1xuICAgIHZhciBuZXdTdGF0ZSA9IHtcbiAgICAgICAgc2NhbGU6IGluaXRpYWxUcmFuc2Zvcm1hdGlvbi5zY2FsZSxcbiAgICAgICAgcG9zaXRpb25YOiBib3VuZGVkUG9zaXRpb25zLngsXG4gICAgICAgIHBvc2l0aW9uWTogYm91bmRlZFBvc2l0aW9ucy55LFxuICAgIH07XG4gICAgaWYgKHNjYWxlID09PSBpbml0aWFsVHJhbnNmb3JtYXRpb24uc2NhbGUgJiZcbiAgICAgICAgcG9zaXRpb25YID09PSBpbml0aWFsVHJhbnNmb3JtYXRpb24ucG9zaXRpb25YICYmXG4gICAgICAgIHBvc2l0aW9uWSA9PT0gaW5pdGlhbFRyYW5zZm9ybWF0aW9uLnBvc2l0aW9uWSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1hdGUoY29udGV4dEluc3RhbmNlLCBuZXdTdGF0ZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVab29tVG9Ob2RlKGNvbnRleHRJbnN0YW5jZSwgbm9kZSwgY3VzdG9tWm9vbSkge1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnNldHVwLCBsaW1pdFRvQm91bmRzID0gX2EubGltaXRUb0JvdW5kcywgbWluU2NhbGUgPSBfYS5taW5TY2FsZSwgbWF4U2NhbGUgPSBfYS5tYXhTY2FsZTtcbiAgICBpZiAoIXdyYXBwZXJDb21wb25lbnQpXG4gICAgICAgIHJldHVybiBpbml0aWFsU3RhdGU7XG4gICAgdmFyIHdyYXBwZXJSZWN0ID0gd3JhcHBlckNvbXBvbmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbm9kZVJlY3QgPSBnZXRPZmZzZXQobm9kZSk7XG4gICAgdmFyIG5vZGVMZWZ0ID0gbm9kZVJlY3QueDtcbiAgICB2YXIgbm9kZVRvcCA9IG5vZGVSZWN0Lnk7XG4gICAgdmFyIG5vZGVXaWR0aCA9IG5vZGUub2Zmc2V0V2lkdGg7XG4gICAgdmFyIG5vZGVIZWlnaHQgPSBub2RlLm9mZnNldEhlaWdodDtcbiAgICB2YXIgc2NhbGVYID0gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRXaWR0aCAvIG5vZGVXaWR0aDtcbiAgICB2YXIgc2NhbGVZID0gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRIZWlnaHQgLyBub2RlSGVpZ2h0O1xuICAgIHZhciBuZXdTY2FsZSA9IGNoZWNrWm9vbUJvdW5kcyhjdXN0b21ab29tIHx8IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKSwgbWluU2NhbGUsIG1heFNjYWxlLCAwLCBmYWxzZSk7XG4gICAgdmFyIG9mZnNldFggPSAod3JhcHBlclJlY3Qud2lkdGggLSBub2RlV2lkdGggKiBuZXdTY2FsZSkgLyAyO1xuICAgIHZhciBvZmZzZXRZID0gKHdyYXBwZXJSZWN0LmhlaWdodCAtIG5vZGVIZWlnaHQgKiBuZXdTY2FsZSkgLyAyO1xuICAgIHZhciBuZXdQb3NpdGlvblggPSAod3JhcHBlclJlY3QubGVmdCAtIG5vZGVMZWZ0KSAqIG5ld1NjYWxlICsgb2Zmc2V0WDtcbiAgICB2YXIgbmV3UG9zaXRpb25ZID0gKHdyYXBwZXJSZWN0LnRvcCAtIG5vZGVUb3ApICogbmV3U2NhbGUgKyBvZmZzZXRZO1xuICAgIHZhciBib3VuZHMgPSBjYWxjdWxhdGVCb3VuZHMoY29udGV4dEluc3RhbmNlLCBuZXdTY2FsZSk7XG4gICAgdmFyIF9iID0gZ2V0TW91c2VCb3VuZGVkUG9zaXRpb24obmV3UG9zaXRpb25YLCBuZXdQb3NpdGlvblksIGJvdW5kcywgbGltaXRUb0JvdW5kcywgMCwgMCwgd3JhcHBlckNvbXBvbmVudCksIHggPSBfYi54LCB5ID0gX2IueTtcbiAgICByZXR1cm4geyBwb3NpdGlvblg6IHgsIHBvc2l0aW9uWTogeSwgc2NhbGU6IG5ld1NjYWxlIH07XG59XG5mdW5jdGlvbiBnZXRPZmZzZXQoZWxlbWVudCkge1xuICAgIHZhciBlbCA9IGVsZW1lbnQ7XG4gICAgdmFyIG9mZnNldExlZnQgPSAwO1xuICAgIHZhciBvZmZzZXRUb3AgPSAwO1xuICAgIHdoaWxlIChlbCkge1xuICAgICAgICBvZmZzZXRMZWZ0ICs9IGVsLm9mZnNldExlZnQ7XG4gICAgICAgIG9mZnNldFRvcCArPSBlbC5vZmZzZXRUb3A7XG4gICAgICAgIGVsID0gZWwub2Zmc2V0UGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBvZmZzZXRMZWZ0LFxuICAgICAgICB5OiBvZmZzZXRUb3AsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRab29tTm9kZShub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJab29tIG5vZGUgbm90IGZvdW5kXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUub2Zmc2V0V2lkdGgpID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5vZmZzZXRIZWlnaHQpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlpvb20gbm9kZSBpcyBub3QgdmFsaWQgLSBpdCBtdXN0IGNvbnRhaW4gb2Zmc2V0V2lkdGggYW5kIG9mZnNldEhlaWdodFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIHpvb21JbiA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGVwLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKSB7XG4gICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkgeyBzdGVwID0gMC41OyB9XG4gICAgaWYgKGFuaW1hdGlvblRpbWUgPT09IHZvaWQgMCkgeyBhbmltYXRpb25UaW1lID0gMzAwOyB9XG4gICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IHZvaWQgMCkgeyBhbmltYXRpb25UeXBlID0gXCJlYXNlT3V0XCI7IH1cbiAgICBoYW5kbGVab29tVG9WaWV3Q2VudGVyKGNvbnRleHRJbnN0YW5jZSwgMSwgc3RlcCwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSk7XG59OyB9O1xudmFyIHpvb21PdXQgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7IHJldHVybiBmdW5jdGlvbiAoc3RlcCwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSkge1xuICAgIGlmIChzdGVwID09PSB2b2lkIDApIHsgc3RlcCA9IDAuNTsgfVxuICAgIGlmIChhbmltYXRpb25UaW1lID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVGltZSA9IDMwMDsgfVxuICAgIGlmIChhbmltYXRpb25UeXBlID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVHlwZSA9IFwiZWFzZU91dFwiOyB9XG4gICAgaGFuZGxlWm9vbVRvVmlld0NlbnRlcihjb250ZXh0SW5zdGFuY2UsIC0xLCBzdGVwLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbn07IH07XG52YXIgc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSkgeyByZXR1cm4gZnVuY3Rpb24gKG5ld1Bvc2l0aW9uWCwgbmV3UG9zaXRpb25ZLCBuZXdTY2FsZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSkge1xuICAgIGlmIChhbmltYXRpb25UaW1lID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVGltZSA9IDMwMDsgfVxuICAgIGlmIChhbmltYXRpb25UeXBlID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVHlwZSA9IFwiZWFzZU91dFwiOyB9XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWSwgc2NhbGUgPSBfYS5zY2FsZTtcbiAgICB2YXIgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLmNvbnRlbnRDb21wb25lbnQ7XG4gICAgdmFyIGRpc2FibGVkID0gY29udGV4dEluc3RhbmNlLnNldHVwLmRpc2FibGVkO1xuICAgIGlmIChkaXNhYmxlZCB8fCAhd3JhcHBlckNvbXBvbmVudCB8fCAhY29udGVudENvbXBvbmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciB0YXJnZXRTdGF0ZSA9IHtcbiAgICAgICAgcG9zaXRpb25YOiBpc05hTihuZXdQb3NpdGlvblgpID8gcG9zaXRpb25YIDogbmV3UG9zaXRpb25YLFxuICAgICAgICBwb3NpdGlvblk6IGlzTmFOKG5ld1Bvc2l0aW9uWSkgPyBwb3NpdGlvblkgOiBuZXdQb3NpdGlvblksXG4gICAgICAgIHNjYWxlOiBpc05hTihuZXdTY2FsZSkgPyBzY2FsZSA6IG5ld1NjYWxlLFxuICAgIH07XG4gICAgYW5pbWF0ZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldFN0YXRlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbn07IH07XG52YXIgcmVzZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7IHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSkge1xuICAgIGlmIChhbmltYXRpb25UaW1lID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVGltZSA9IDIwMDsgfVxuICAgIGlmIChhbmltYXRpb25UeXBlID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVHlwZSA9IFwiZWFzZU91dFwiOyB9XG4gICAgcmVzZXRUcmFuc2Zvcm1hdGlvbnMoY29udGV4dEluc3RhbmNlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbn07IH07XG52YXIgY2VudGVyVmlldyA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHsgcmV0dXJuIGZ1bmN0aW9uIChzY2FsZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSkge1xuICAgIGlmIChhbmltYXRpb25UaW1lID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVGltZSA9IDIwMDsgfVxuICAgIGlmIChhbmltYXRpb25UeXBlID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVHlwZSA9IFwiZWFzZU91dFwiOyB9XG4gICAgdmFyIHRyYW5zZm9ybVN0YXRlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudDtcbiAgICBpZiAod3JhcHBlckNvbXBvbmVudCAmJiBjb250ZW50Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXRTdGF0ZSA9IGdldENlbnRlclBvc2l0aW9uKHNjYWxlIHx8IHRyYW5zZm9ybVN0YXRlLnNjYWxlLCB3cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50KTtcbiAgICAgICAgYW5pbWF0ZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldFN0YXRlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbiAgICB9XG59OyB9O1xudmFyIHpvb21Ub0VsZW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7IHJldHVybiBmdW5jdGlvbiAobm9kZSwgc2NhbGUsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblRpbWUgPSA2MDA7IH1cbiAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblR5cGUgPSBcImVhc2VPdXRcIjsgfVxuICAgIGhhbmRsZUNhbmNlbEFuaW1hdGlvbihjb250ZXh0SW5zdGFuY2UpO1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgdmFyIHRhcmdldCA9IHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZSkgOiBub2RlO1xuICAgIGlmICh3cmFwcGVyQ29tcG9uZW50ICYmXG4gICAgICAgIGlzVmFsaWRab29tTm9kZSh0YXJnZXQpICYmXG4gICAgICAgIHRhcmdldCAmJlxuICAgICAgICB3cmFwcGVyQ29tcG9uZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgdmFyIHRhcmdldFN0YXRlID0gY2FsY3VsYXRlWm9vbVRvTm9kZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldCwgc2NhbGUpO1xuICAgICAgICBhbmltYXRlKGNvbnRleHRJbnN0YW5jZSwgdGFyZ2V0U3RhdGUsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpO1xuICAgIH1cbn07IH07XG5cbnZhciBnZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluc3RhbmNlOiBjb250ZXh0SW5zdGFuY2UsXG4gICAgICAgIHN0YXRlOiBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUsXG4gICAgICAgIHpvb21Jbjogem9vbUluKGNvbnRleHRJbnN0YW5jZSksXG4gICAgICAgIHpvb21PdXQ6IHpvb21PdXQoY29udGV4dEluc3RhbmNlKSxcbiAgICAgICAgc2V0VHJhbnNmb3JtOiBzZXRUcmFuc2Zvcm0oY29udGV4dEluc3RhbmNlKSxcbiAgICAgICAgcmVzZXRUcmFuc2Zvcm06IHJlc2V0VHJhbnNmb3JtKGNvbnRleHRJbnN0YW5jZSksXG4gICAgICAgIGNlbnRlclZpZXc6IGNlbnRlclZpZXcoY29udGV4dEluc3RhbmNlKSxcbiAgICAgICAgem9vbVRvRWxlbWVudDogem9vbVRvRWxlbWVudChjb250ZXh0SW5zdGFuY2UpLFxuICAgIH07XG59O1xuXG4vLyBXZSB3YW50IHRvIG1ha2UgZXZlbnQgbGlzdGVuZXJzIG5vbi1wYXNzaXZlLCBhbmQgdG8gZG8gc28gaGF2ZSB0byBjaGVja1xuLy8gdGhhdCBicm93c2VycyBzdXBwb3J0IEV2ZW50TGlzdGVuZXJPcHRpb25zIGluIHRoZSBmaXJzdCBwbGFjZS5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1NhZmVseV9kZXRlY3Rpbmdfb3B0aW9uX3N1cHBvcnRcbnZhciBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG5mdW5jdGlvbiBtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gICBhdHRlbXB0cyB0byBhY2Nlc3MgdGhlIHBhc3NpdmUgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbiAgICB9XG59XG5cbnZhciBpc0V4Y2x1ZGVkTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBleGNsdWRlZCkge1xuICAgIHZhciB0YXJnZXRUYWdOYW1lID0gbm9kZS50YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIGlzRXhjbHVkZWRUYWcgPSBleGNsdWRlZC5maW5kKGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZy50b1VwcGVyQ2FzZSgpID09PSB0YXJnZXRUYWdOYW1lOyB9KTtcbiAgICBpZiAoaXNFeGNsdWRlZFRhZylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdmFyIGlzRXhjbHVkZWRDbGFzc05hbWUgPSBleGNsdWRlZC5maW5kKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgfSk7XG4gICAgaWYgKGlzRXhjbHVkZWRDbGFzc05hbWUpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG52YXIgY2FuY2VsVGltZW91dCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbn07XG5cbnZhciBnZXRUcmFuc2Zvcm1TdHlsZXMgPSBmdW5jdGlvbiAoeCwgeSwgc2NhbGUpIHtcbiAgICByZXR1cm4gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKSBzY2FsZShcIiArIHNjYWxlICsgXCIpXCI7XG59O1xudmFyIGdldENlbnRlclBvc2l0aW9uID0gZnVuY3Rpb24gKHNjYWxlLCB3cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50KSB7XG4gICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRlbnRDb21wb25lbnQub2Zmc2V0V2lkdGggKiBzY2FsZTtcbiAgICB2YXIgY29udGVudEhlaWdodCA9IGNvbnRlbnRDb21wb25lbnQub2Zmc2V0SGVpZ2h0ICogc2NhbGU7XG4gICAgdmFyIGNlbnRlclBvc2l0aW9uWCA9ICh3cmFwcGVyQ29tcG9uZW50Lm9mZnNldFdpZHRoIC0gY29udGVudFdpZHRoKSAvIDI7XG4gICAgdmFyIGNlbnRlclBvc2l0aW9uWSA9ICh3cmFwcGVyQ29tcG9uZW50Lm9mZnNldEhlaWdodCAtIGNvbnRlbnRIZWlnaHQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIHBvc2l0aW9uWDogY2VudGVyUG9zaXRpb25YLFxuICAgICAgICBwb3NpdGlvblk6IGNlbnRlclBvc2l0aW9uWSxcbiAgICB9O1xufTtcblxudmFyIGlzV2hlZWxBbGxvd2VkID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAud2hlZWwsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIHdoZWVsRGlzYWJsZWQgPSBfYS53aGVlbERpc2FibGVkLCB0b3VjaFBhZERpc2FibGVkID0gX2EudG91Y2hQYWREaXNhYmxlZCwgZXhjbHVkZWQgPSBfYS5leGNsdWRlZDtcbiAgICB2YXIgaXNJbml0aWFsaXplZCA9IGNvbnRleHRJbnN0YW5jZS5pc0luaXRpYWxpemVkLCBpc1Bhbm5pbmcgPSBjb250ZXh0SW5zdGFuY2UuaXNQYW5uaW5nO1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgIWlzUGFubmluZyAmJiAhZGlzYWJsZWQgJiYgdGFyZ2V0O1xuICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gRXZlbnQgY3RybEtleSBkZXRlY3RzIGlmIHRvdWNocGFkIGFjdGlvbiBpcyBleGVjdXRpbmcgd2hlZWwgb3IgcGluY2ggZ2VzdHVyZVxuICAgIGlmICh3aGVlbERpc2FibGVkICYmICFldmVudC5jdHJsS2V5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRvdWNoUGFkRGlzYWJsZWQgJiYgZXZlbnQuY3RybEtleSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBpc0V4Y2x1ZGVkID0gaXNFeGNsdWRlZE5vZGUodGFyZ2V0LCBleGNsdWRlZCk7XG4gICAgaWYgKGlzRXhjbHVkZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBnZXREZWx0YShldmVudCwgY3VzdG9tRGVsdGEpIHtcbiAgICB2YXIgZGVsdGFZID0gZXZlbnQgPyAoZXZlbnQuZGVsdGFZIDwgMCA/IDEgOiAtMSkgOiAwO1xuICAgIHZhciBkZWx0YSA9IGNoZWNrSXNOdW1iZXIoY3VzdG9tRGVsdGEsIGRlbHRhWSk7XG4gICAgcmV0dXJuIGRlbHRhO1xufVxuZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY29udGVudENvbXBvbmVudCwgc2NhbGUpIHtcbiAgICB2YXIgY29udGVudFJlY3QgPSBjb250ZW50Q29tcG9uZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBtb3VzZVggPSAwO1xuICAgIHZhciBtb3VzZVkgPSAwO1xuICAgIGlmIChcImNsaWVudFhcIiBpbiBldmVudCkge1xuICAgICAgICAvLyBtb3VzZSBwb3NpdGlvbiB4LCB5IG92ZXIgd3JhcHBlciBjb21wb25lbnRcbiAgICAgICAgbW91c2VYID0gKGV2ZW50LmNsaWVudFggLSBjb250ZW50UmVjdC5sZWZ0KSAvIHNjYWxlO1xuICAgICAgICBtb3VzZVkgPSAoZXZlbnQuY2xpZW50WSAtIGNvbnRlbnRSZWN0LnRvcCkgLyBzY2FsZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICAgIG1vdXNlWCA9ICh0b3VjaC5jbGllbnRYIC0gY29udGVudFJlY3QubGVmdCkgLyBzY2FsZTtcbiAgICAgICAgbW91c2VZID0gKHRvdWNoLmNsaWVudFkgLSBjb250ZW50UmVjdC50b3ApIC8gc2NhbGU7XG4gICAgfVxuICAgIGlmIChpc05hTihtb3VzZVgpIHx8IGlzTmFOKG1vdXNlWSkpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBtb3VzZSBvciB0b3VjaCBvZmZzZXQgZm91bmRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogbW91c2VYLFxuICAgICAgICB5OiBtb3VzZVksXG4gICAgfTtcbn1cbnZhciBoYW5kbGVDYWxjdWxhdGVXaGVlbFpvb20gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBkZWx0YSwgc3RlcCwgZGlzYWJsZVBhZGRpbmcsIGdldFRhcmdldCkge1xuICAgIHZhciBzY2FsZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICB2YXIgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50LCBzZXR1cCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cDtcbiAgICB2YXIgbWF4U2NhbGUgPSBzZXR1cC5tYXhTY2FsZSwgbWluU2NhbGUgPSBzZXR1cC5taW5TY2FsZSwgem9vbUFuaW1hdGlvbiA9IHNldHVwLnpvb21BbmltYXRpb247XG4gICAgdmFyIHNpemUgPSB6b29tQW5pbWF0aW9uLnNpemUsIGRpc2FibGVkID0gem9vbUFuaW1hdGlvbi5kaXNhYmxlZDtcbiAgICBpZiAoIXdyYXBwZXJDb21wb25lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JhcHBlciBpcyBub3QgbW91bnRlZFwiKTtcbiAgICB9XG4gICAgdmFyIHRhcmdldFNjYWxlID0gc2NhbGUgKyBkZWx0YSAqIChzY2FsZSAtIHNjYWxlICogc3RlcCkgKiBzdGVwO1xuICAgIGlmIChnZXRUYXJnZXQpXG4gICAgICAgIHJldHVybiB0YXJnZXRTY2FsZTtcbiAgICB2YXIgcGFkZGluZ0VuYWJsZWQgPSBkaXNhYmxlUGFkZGluZyA/IGZhbHNlIDogIWRpc2FibGVkO1xuICAgIHZhciBuZXdTY2FsZSA9IGNoZWNrWm9vbUJvdW5kcyhyb3VuZE51bWJlcih0YXJnZXRTY2FsZSwgMyksIG1pblNjYWxlLCBtYXhTY2FsZSwgc2l6ZSwgcGFkZGluZ0VuYWJsZWQpO1xuICAgIHJldHVybiBuZXdTY2FsZTtcbn07XG52YXIgaGFuZGxlV2hlZWxab29tU3RvcCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIHByZXZpb3VzV2hlZWxFdmVudCA9IGNvbnRleHRJbnN0YW5jZS5wcmV2aW91c1doZWVsRXZlbnQ7XG4gICAgdmFyIHNjYWxlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgbWF4U2NhbGUgPSBfYS5tYXhTY2FsZSwgbWluU2NhbGUgPSBfYS5taW5TY2FsZTtcbiAgICBpZiAoIXByZXZpb3VzV2hlZWxFdmVudClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChzY2FsZSA8IG1heFNjYWxlIHx8IHNjYWxlID4gbWluU2NhbGUpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChNYXRoLnNpZ24ocHJldmlvdXNXaGVlbEV2ZW50LmRlbHRhWSkgIT09IE1hdGguc2lnbihldmVudC5kZWx0YVkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAocHJldmlvdXNXaGVlbEV2ZW50LmRlbHRhWSA+IDAgJiYgcHJldmlvdXNXaGVlbEV2ZW50LmRlbHRhWSA8IGV2ZW50LmRlbHRhWSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHByZXZpb3VzV2hlZWxFdmVudC5kZWx0YVkgPCAwICYmIHByZXZpb3VzV2hlZWxFdmVudC5kZWx0YVkgPiBldmVudC5kZWx0YVkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChNYXRoLnNpZ24ocHJldmlvdXNXaGVlbEV2ZW50LmRlbHRhWSkgIT09IE1hdGguc2lnbihldmVudC5kZWx0YVkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgaXNQaW5jaFN0YXJ0QWxsb3dlZCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnNldHVwLnBpbmNoLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBleGNsdWRlZCA9IF9hLmV4Y2x1ZGVkO1xuICAgIHZhciBpc0luaXRpYWxpemVkID0gY29udGV4dEluc3RhbmNlLmlzSW5pdGlhbGl6ZWQ7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgaXNBbGxvd2VkID0gaXNJbml0aWFsaXplZCAmJiAhZGlzYWJsZWQgJiYgdGFyZ2V0O1xuICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGlzRXhjbHVkZWQgPSBpc0V4Y2x1ZGVkTm9kZSh0YXJnZXQsIGV4Y2x1ZGVkKTtcbiAgICBpZiAoaXNFeGNsdWRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufTtcbnZhciBpc1BpbmNoQWxsb3dlZCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICB2YXIgZGlzYWJsZWQgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAucGluY2guZGlzYWJsZWQ7XG4gICAgdmFyIGlzSW5pdGlhbGl6ZWQgPSBjb250ZXh0SW5zdGFuY2UuaXNJbml0aWFsaXplZCwgcGluY2hTdGFydERpc3RhbmNlID0gY29udGV4dEluc3RhbmNlLnBpbmNoU3RhcnREaXN0YW5jZTtcbiAgICB2YXIgaXNBbGxvd2VkID0gaXNJbml0aWFsaXplZCAmJiAhZGlzYWJsZWQgJiYgcGluY2hTdGFydERpc3RhbmNlO1xuICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xudmFyIGNhbGN1bGF0ZVRvdWNoTWlkUG9pbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHNjYWxlLCBjb250ZW50Q29tcG9uZW50KSB7XG4gICAgdmFyIGNvbnRlbnRSZWN0ID0gY29udGVudENvbXBvbmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG4gICAgdmFyIGZpcnN0UG9pbnRYID0gcm91bmROdW1iZXIodG91Y2hlc1swXS5jbGllbnRYIC0gY29udGVudFJlY3QubGVmdCwgNSk7XG4gICAgdmFyIGZpcnN0UG9pbnRZID0gcm91bmROdW1iZXIodG91Y2hlc1swXS5jbGllbnRZIC0gY29udGVudFJlY3QudG9wLCA1KTtcbiAgICB2YXIgc2Vjb25kUG9pbnRYID0gcm91bmROdW1iZXIodG91Y2hlc1sxXS5jbGllbnRYIC0gY29udGVudFJlY3QubGVmdCwgNSk7XG4gICAgdmFyIHNlY29uZFBvaW50WSA9IHJvdW5kTnVtYmVyKHRvdWNoZXNbMV0uY2xpZW50WSAtIGNvbnRlbnRSZWN0LnRvcCwgNSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogKGZpcnN0UG9pbnRYICsgc2Vjb25kUG9pbnRYKSAvIDIgLyBzY2FsZSxcbiAgICAgICAgeTogKGZpcnN0UG9pbnRZICsgc2Vjb25kUG9pbnRZKSAvIDIgLyBzY2FsZSxcbiAgICB9O1xufTtcbnZhciBnZXRUb3VjaERpc3RhbmNlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWCwgMikgK1xuICAgICAgICBNYXRoLnBvdyhldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWSwgMikpO1xufTtcbnZhciBjYWxjdWxhdGVQaW5jaFpvb20gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBjdXJyZW50RGlzdGFuY2UpIHtcbiAgICB2YXIgcGluY2hTdGFydFNjYWxlID0gY29udGV4dEluc3RhbmNlLnBpbmNoU3RhcnRTY2FsZSwgcGluY2hTdGFydERpc3RhbmNlID0gY29udGV4dEluc3RhbmNlLnBpbmNoU3RhcnREaXN0YW5jZSwgc2V0dXAgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXA7XG4gICAgdmFyIG1heFNjYWxlID0gc2V0dXAubWF4U2NhbGUsIG1pblNjYWxlID0gc2V0dXAubWluU2NhbGUsIHpvb21BbmltYXRpb24gPSBzZXR1cC56b29tQW5pbWF0aW9uO1xuICAgIHZhciBzaXplID0gem9vbUFuaW1hdGlvbi5zaXplLCBkaXNhYmxlZCA9IHpvb21BbmltYXRpb24uZGlzYWJsZWQ7XG4gICAgaWYgKCFwaW5jaFN0YXJ0U2NhbGUgfHwgcGluY2hTdGFydERpc3RhbmNlID09PSBudWxsIHx8ICFjdXJyZW50RGlzdGFuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGluY2ggdG91Y2hlcyBkaXN0YW5jZSB3YXMgbm90IHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudERpc3RhbmNlIDwgMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIH1cbiAgICB2YXIgdG91Y2hQcm9wb3J0aW9uID0gY3VycmVudERpc3RhbmNlIC8gcGluY2hTdGFydERpc3RhbmNlO1xuICAgIHZhciBzY2FsZURpZmZlcmVuY2UgPSB0b3VjaFByb3BvcnRpb24gKiBwaW5jaFN0YXJ0U2NhbGU7XG4gICAgcmV0dXJuIGNoZWNrWm9vbUJvdW5kcyhyb3VuZE51bWJlcihzY2FsZURpZmZlcmVuY2UsIDIpLCBtaW5TY2FsZSwgbWF4U2NhbGUsIHNpemUsICFkaXNhYmxlZCk7XG59O1xuXG52YXIgd2hlZWxTdG9wRXZlbnRUaW1lID0gMTYwO1xudmFyIHdoZWVsQW5pbWF0aW9uVGltZSA9IDEwMDtcbnZhciBoYW5kbGVXaGVlbFN0YXJ0ID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UucHJvcHMsIG9uV2hlZWxTdGFydCA9IF9hLm9uV2hlZWxTdGFydCwgb25ab29tU3RhcnQgPSBfYS5vblpvb21TdGFydDtcbiAgICBpZiAoIWNvbnRleHRJbnN0YW5jZS53aGVlbFN0b3BFdmVudFRpbWVyKSB7XG4gICAgICAgIGhhbmRsZUNhbmNlbEFuaW1hdGlvbihjb250ZXh0SW5zdGFuY2UpO1xuICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KGNvbnRleHRJbnN0YW5jZSksIGV2ZW50LCBvbldoZWVsU3RhcnQpO1xuICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KGNvbnRleHRJbnN0YW5jZSksIGV2ZW50LCBvblpvb21TdGFydCk7XG4gICAgfVxufTtcbnZhciBoYW5kbGVXaGVlbFpvb20gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5wcm9wcywgb25XaGVlbCA9IF9hLm9uV2hlZWwsIG9uWm9vbSA9IF9hLm9uWm9vbTtcbiAgICB2YXIgY29udGVudENvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS5jb250ZW50Q29tcG9uZW50LCBzZXR1cCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgdHJhbnNmb3JtU3RhdGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGU7XG4gICAgdmFyIHNjYWxlID0gdHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgdmFyIGxpbWl0VG9Cb3VuZHMgPSBzZXR1cC5saW1pdFRvQm91bmRzLCBjZW50ZXJab29tZWRPdXQgPSBzZXR1cC5jZW50ZXJab29tZWRPdXQsIHpvb21BbmltYXRpb24gPSBzZXR1cC56b29tQW5pbWF0aW9uLCB3aGVlbCA9IHNldHVwLndoZWVsO1xuICAgIHZhciBzaXplID0gem9vbUFuaW1hdGlvbi5zaXplLCBkaXNhYmxlZCA9IHpvb21BbmltYXRpb24uZGlzYWJsZWQ7XG4gICAgdmFyIHN0ZXAgPSB3aGVlbC5zdGVwO1xuICAgIGlmICghY29udGVudENvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnQgbm90IG1vdW50ZWRcIik7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdmFyIGRlbHRhID0gZ2V0RGVsdGEoZXZlbnQsIG51bGwpO1xuICAgIHZhciBuZXdTY2FsZSA9IGhhbmRsZUNhbGN1bGF0ZVdoZWVsWm9vbShjb250ZXh0SW5zdGFuY2UsIGRlbHRhLCBzdGVwLCAhZXZlbnQuY3RybEtleSk7XG4gICAgLy8gaWYgc2NhbGUgbm90IGNoYW5nZVxuICAgIGlmIChzY2FsZSA9PT0gbmV3U2NhbGUpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgYm91bmRzID0gaGFuZGxlQ2FsY3VsYXRlQm91bmRzKGNvbnRleHRJbnN0YW5jZSwgbmV3U2NhbGUpO1xuICAgIHZhciBtb3VzZVBvc2l0aW9uID0gZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY29udGVudENvbXBvbmVudCwgc2NhbGUpO1xuICAgIHZhciBpc1BhZGRpbmdEaXNhYmxlZCA9IGRpc2FibGVkIHx8IHNpemUgPT09IDAgfHwgY2VudGVyWm9vbWVkT3V0O1xuICAgIHZhciBpc0xpbWl0ZWRUb0JvdW5kcyA9IGxpbWl0VG9Cb3VuZHMgJiYgaXNQYWRkaW5nRGlzYWJsZWQ7XG4gICAgdmFyIF9iID0gaGFuZGxlQ2FsY3VsYXRlWm9vbVBvc2l0aW9ucyhjb250ZXh0SW5zdGFuY2UsIG1vdXNlUG9zaXRpb24ueCwgbW91c2VQb3NpdGlvbi55LCBuZXdTY2FsZSwgYm91bmRzLCBpc0xpbWl0ZWRUb0JvdW5kcyksIHggPSBfYi54LCB5ID0gX2IueTtcbiAgICBjb250ZXh0SW5zdGFuY2UucHJldmlvdXNXaGVlbEV2ZW50ID0gZXZlbnQ7XG4gICAgY29udGV4dEluc3RhbmNlLnNldFRyYW5zZm9ybVN0YXRlKG5ld1NjYWxlLCB4LCB5KTtcbiAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KGNvbnRleHRJbnN0YW5jZSksIGV2ZW50LCBvbldoZWVsKTtcbiAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KGNvbnRleHRJbnN0YW5jZSksIGV2ZW50LCBvblpvb20pO1xufTtcbnZhciBoYW5kbGVXaGVlbFN0b3AgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5wcm9wcywgb25XaGVlbFN0b3AgPSBfYS5vbldoZWVsU3RvcCwgb25ab29tU3RvcCA9IF9hLm9uWm9vbVN0b3A7XG4gICAgLy8gZmlyZSBhbmltYXRpb25cbiAgICBjYW5jZWxUaW1lb3V0KGNvbnRleHRJbnN0YW5jZS53aGVlbEFuaW1hdGlvblRpbWVyKTtcbiAgICBjb250ZXh0SW5zdGFuY2Uud2hlZWxBbmltYXRpb25UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWNvbnRleHRJbnN0YW5jZS5tb3VudGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBoYW5kbGVBbGlnblRvU2NhbGVCb3VuZHMoY29udGV4dEluc3RhbmNlLCBldmVudC54LCBldmVudC55KTtcbiAgICAgICAgY29udGV4dEluc3RhbmNlLndoZWVsQW5pbWF0aW9uVGltZXIgPSBudWxsO1xuICAgIH0sIHdoZWVsQW5pbWF0aW9uVGltZSk7XG4gICAgLy8gV2hlZWwgc3RvcCBldmVudFxuICAgIHZhciBoYXNTdG9wcGVkWm9vbWluZyA9IGhhbmRsZVdoZWVsWm9vbVN0b3AoY29udGV4dEluc3RhbmNlLCBldmVudCk7XG4gICAgaWYgKGhhc1N0b3BwZWRab29taW5nKSB7XG4gICAgICAgIGNhbmNlbFRpbWVvdXQoY29udGV4dEluc3RhbmNlLndoZWVsU3RvcEV2ZW50VGltZXIpO1xuICAgICAgICBjb250ZXh0SW5zdGFuY2Uud2hlZWxTdG9wRXZlbnRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0SW5zdGFuY2UubW91bnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb250ZXh0SW5zdGFuY2Uud2hlZWxTdG9wRXZlbnRUaW1lciA9IG51bGw7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KGNvbnRleHRJbnN0YW5jZSksIGV2ZW50LCBvbldoZWVsU3RvcCk7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KGNvbnRleHRJbnN0YW5jZSksIGV2ZW50LCBvblpvb21TdG9wKTtcbiAgICAgICAgfSwgd2hlZWxTdG9wRXZlbnRUaW1lKTtcbiAgICB9XG59O1xuXG52YXIgaGFuZGxlUGluY2hTdGFydCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIGRpc3RhbmNlID0gZ2V0VG91Y2hEaXN0YW5jZShldmVudCk7XG4gICAgY29udGV4dEluc3RhbmNlLnBpbmNoU3RhcnREaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIGNvbnRleHRJbnN0YW5jZS5sYXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICBjb250ZXh0SW5zdGFuY2UucGluY2hTdGFydFNjYWxlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIGNvbnRleHRJbnN0YW5jZS5pc1Bhbm5pbmcgPSBmYWxzZTtcbiAgICBoYW5kbGVDYW5jZWxBbmltYXRpb24oY29udGV4dEluc3RhbmNlKTtcbn07XG52YXIgaGFuZGxlUGluY2hab29tID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgY29udGVudENvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS5jb250ZW50Q29tcG9uZW50LCBwaW5jaFN0YXJ0RGlzdGFuY2UgPSBjb250ZXh0SW5zdGFuY2UucGluY2hTdGFydERpc3RhbmNlO1xuICAgIHZhciBzY2FsZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIGxpbWl0VG9Cb3VuZHMgPSBfYS5saW1pdFRvQm91bmRzLCBjZW50ZXJab29tZWRPdXQgPSBfYS5jZW50ZXJab29tZWRPdXQsIHpvb21BbmltYXRpb24gPSBfYS56b29tQW5pbWF0aW9uO1xuICAgIHZhciBkaXNhYmxlZCA9IHpvb21BbmltYXRpb24uZGlzYWJsZWQsIHNpemUgPSB6b29tQW5pbWF0aW9uLnNpemU7XG4gICAgLy8gaWYgb25lIGZpbmdlciBzdGFydHMgZnJvbSBvdXRzaWRlIG9mIHdyYXBwZXJcbiAgICBpZiAocGluY2hTdGFydERpc3RhbmNlID09PSBudWxsIHx8ICFjb250ZW50Q29tcG9uZW50KVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIG1pZFBvaW50ID0gY2FsY3VsYXRlVG91Y2hNaWRQb2ludChldmVudCwgc2NhbGUsIGNvbnRlbnRDb21wb25lbnQpO1xuICAgIC8vIGlmIHRvdWNoZXMgZ29lcyBvZmYgb2YgdGhlIHdyYXBwZXIgZWxlbWVudFxuICAgIGlmICghaXNGaW5pdGUobWlkUG9pbnQueCkgfHwgIWlzRmluaXRlKG1pZFBvaW50LnkpKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IGdldFRvdWNoRGlzdGFuY2UoZXZlbnQpO1xuICAgIHZhciBuZXdTY2FsZSA9IGNhbGN1bGF0ZVBpbmNoWm9vbShjb250ZXh0SW5zdGFuY2UsIGN1cnJlbnREaXN0YW5jZSk7XG4gICAgaWYgKG5ld1NjYWxlID09PSBzY2FsZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBib3VuZHMgPSBoYW5kbGVDYWxjdWxhdGVCb3VuZHMoY29udGV4dEluc3RhbmNlLCBuZXdTY2FsZSk7XG4gICAgdmFyIGlzUGFkZGluZ0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgc2l6ZSA9PT0gMCB8fCBjZW50ZXJab29tZWRPdXQ7XG4gICAgdmFyIGlzTGltaXRlZFRvQm91bmRzID0gbGltaXRUb0JvdW5kcyAmJiBpc1BhZGRpbmdEaXNhYmxlZDtcbiAgICB2YXIgX2IgPSBoYW5kbGVDYWxjdWxhdGVab29tUG9zaXRpb25zKGNvbnRleHRJbnN0YW5jZSwgbWlkUG9pbnQueCwgbWlkUG9pbnQueSwgbmV3U2NhbGUsIGJvdW5kcywgaXNMaW1pdGVkVG9Cb3VuZHMpLCB4ID0gX2IueCwgeSA9IF9iLnk7XG4gICAgY29udGV4dEluc3RhbmNlLnBpbmNoTWlkcG9pbnQgPSBtaWRQb2ludDtcbiAgICBjb250ZXh0SW5zdGFuY2UubGFzdERpc3RhbmNlID0gY3VycmVudERpc3RhbmNlO1xuICAgIGNvbnRleHRJbnN0YW5jZS5zZXRUcmFuc2Zvcm1TdGF0ZShuZXdTY2FsZSwgeCwgeSk7XG59O1xudmFyIGhhbmRsZVBpbmNoU3RvcCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICB2YXIgcGluY2hNaWRwb2ludCA9IGNvbnRleHRJbnN0YW5jZS5waW5jaE1pZHBvaW50O1xuICAgIGNvbnRleHRJbnN0YW5jZS52ZWxvY2l0eSA9IG51bGw7XG4gICAgY29udGV4dEluc3RhbmNlLmxhc3REaXN0YW5jZSA9IG51bGw7XG4gICAgY29udGV4dEluc3RhbmNlLnBpbmNoTWlkcG9pbnQgPSBudWxsO1xuICAgIGNvbnRleHRJbnN0YW5jZS5waW5jaFN0YXJ0U2NhbGUgPSBudWxsO1xuICAgIGNvbnRleHRJbnN0YW5jZS5waW5jaFN0YXJ0RGlzdGFuY2UgPSBudWxsO1xuICAgIGhhbmRsZUFsaWduVG9TY2FsZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIHBpbmNoTWlkcG9pbnQgPT09IG51bGwgfHwgcGluY2hNaWRwb2ludCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGluY2hNaWRwb2ludC54LCBwaW5jaE1pZHBvaW50ID09PSBudWxsIHx8IHBpbmNoTWlkcG9pbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBpbmNoTWlkcG9pbnQueSk7XG59O1xuXG5mdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayhjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnNldHVwLmRvdWJsZUNsaWNrLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBtb2RlID0gX2EubW9kZSwgc3RlcCA9IF9hLnN0ZXAsIGFuaW1hdGlvblRpbWUgPSBfYS5hbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlID0gX2EuYW5pbWF0aW9uVHlwZTtcbiAgICBpZiAoZGlzYWJsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAobW9kZSA9PT0gXCJyZXNldFwiKSB7XG4gICAgICAgIHJldHVybiByZXNldFRyYW5zZm9ybWF0aW9ucyhjb250ZXh0SW5zdGFuY2UsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpO1xuICAgIH1cbiAgICB2YXIgc2NhbGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgdmFyIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudDtcbiAgICBpZiAoIWNvbnRlbnRDb21wb25lbnQpXG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiTm8gQ29udGVudENvbXBvbmVudCBmb3VuZFwiKTtcbiAgICB2YXIgZGVsdGEgPSBtb2RlID09PSBcInpvb21PdXRcIiA/IC0xIDogMTtcbiAgICB2YXIgbmV3U2NhbGUgPSBoYW5kbGVDYWxjdWxhdGVCdXR0b25ab29tKGNvbnRleHRJbnN0YW5jZSwgZGVsdGEsIHN0ZXApO1xuICAgIHZhciBtb3VzZVBvc2l0aW9uID0gZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY29udGVudENvbXBvbmVudCwgc2NhbGUpO1xuICAgIHZhciB0YXJnZXRTdGF0ZSA9IGhhbmRsZVpvb21Ub1BvaW50KGNvbnRleHRJbnN0YW5jZSwgbmV3U2NhbGUsIG1vdXNlUG9zaXRpb24ueCwgbW91c2VQb3NpdGlvbi55KTtcbiAgICBpZiAoIXRhcmdldFN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIHpvb20gZXZlbnQuIE5ldyB0cmFuc2Zvcm1hdGlvbiBzdGF0ZSB3YXMgbm90IGNhbGN1bGF0ZWQuXCIpO1xuICAgIH1cbiAgICBhbmltYXRlKGNvbnRleHRJbnN0YW5jZSwgdGFyZ2V0U3RhdGUsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpO1xufVxudmFyIGlzRG91YmxlQ2xpY2tBbGxvd2VkID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgaXNJbml0aWFsaXplZCA9IGNvbnRleHRJbnN0YW5jZS5pc0luaXRpYWxpemVkLCBzZXR1cCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50O1xuICAgIHZhciBfYSA9IHNldHVwLmRvdWJsZUNsaWNrLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBleGNsdWRlZCA9IF9hLmV4Y2x1ZGVkO1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGlzV3JhcHBlckNoaWxkID0gd3JhcHBlckNvbXBvbmVudCA9PT0gbnVsbCB8fCB3cmFwcGVyQ29tcG9uZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3cmFwcGVyQ29tcG9uZW50LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgdGFyZ2V0ICYmIGlzV3JhcHBlckNoaWxkICYmICFkaXNhYmxlZDtcbiAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBpc0V4Y2x1ZGVkID0gaXNFeGNsdWRlZE5vZGUodGFyZ2V0LCBleGNsdWRlZCk7XG4gICAgaWYgKGlzRXhjbHVkZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxudmFyIENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KGNvbnRleHRJbml0aWFsU3RhdGUpO1xudmFyIFRyYW5zZm9ybUNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYW5zZm9ybUNvbnRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtQ29udGV4dCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICBfdGhpcy50cmFuc2Zvcm1TdGF0ZSA9IGNyZWF0ZVN0YXRlKF90aGlzLnByb3BzKTtcbiAgICAgICAgX3RoaXMuc2V0dXAgPSBjcmVhdGVTZXR1cChfdGhpcy5wcm9wcyk7XG4gICAgICAgIC8vIENvbXBvbmVudHNcbiAgICAgICAgX3RoaXMud3JhcHBlckNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIF90aGlzLmNvbnRlbnRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICAvLyBJbml0aWFsaXphdGlvblxuICAgICAgICBfdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIC8vIHdoZWVsIGhlbHBlcnNcbiAgICAgICAgX3RoaXMucHJldmlvdXNXaGVlbEV2ZW50ID0gbnVsbDtcbiAgICAgICAgX3RoaXMud2hlZWxTdG9wRXZlbnRUaW1lciA9IG51bGw7XG4gICAgICAgIF90aGlzLndoZWVsQW5pbWF0aW9uVGltZXIgPSBudWxsO1xuICAgICAgICAvLyBwYW5uaW5nIGhlbHBlcnNcbiAgICAgICAgX3RoaXMuaXNQYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnN0YXJ0Q29vcmRzID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdFRvdWNoID0gbnVsbDtcbiAgICAgICAgLy8gcGluY2ggaGVscGVyc1xuICAgICAgICBfdGhpcy5kaXN0YW5jZSA9IG51bGw7XG4gICAgICAgIF90aGlzLmxhc3REaXN0YW5jZSA9IG51bGw7XG4gICAgICAgIF90aGlzLnBpbmNoU3RhcnREaXN0YW5jZSA9IG51bGw7XG4gICAgICAgIF90aGlzLnBpbmNoU3RhcnRTY2FsZSA9IG51bGw7XG4gICAgICAgIF90aGlzLnBpbmNoTWlkcG9pbnQgPSBudWxsO1xuICAgICAgICAvLyB2ZWxvY2l0eSBoZWxwZXJzXG4gICAgICAgIF90aGlzLnZlbG9jaXR5ID0gbnVsbDtcbiAgICAgICAgX3RoaXMudmVsb2NpdHlUaW1lID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdE1vdXNlUG9zaXRpb24gPSBudWxsO1xuICAgICAgICAvLyBhbmltYXRpb25zIGhlbHBlcnNcbiAgICAgICAgX3RoaXMuYW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5hbmltYXRpb24gPSBudWxsO1xuICAgICAgICBfdGhpcy5tYXhCb3VuZHMgPSBudWxsO1xuICAgICAgICAvLyBrZXkgcHJlc3NcbiAgICAgICAgX3RoaXMucHJlc3NlZEtleXMgPSB7fTtcbiAgICAgICAgX3RoaXMuaGFuZGxlSW5pdGlhbGl6ZVdyYXBwZXJFdmVudHMgPSBmdW5jdGlvbiAod3JhcHBlcikge1xuICAgICAgICAgICAgLy8gWm9vbWluZyBldmVudHMgb24gd3JhcHBlclxuICAgICAgICAgICAgdmFyIHBhc3NpdmUgPSBtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uKCk7XG4gICAgICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBfdGhpcy5vbldoZWVsWm9vbSwgcGFzc2l2ZSk7XG4gICAgICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCBfdGhpcy5vbkRvdWJsZUNsaWNrLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIHdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX3RoaXMub25Ub3VjaFBhbm5pbmdTdGFydCwgcGFzc2l2ZSk7XG4gICAgICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgX3RoaXMub25Ub3VjaFBhbm5pbmcsIHBhc3NpdmUpO1xuICAgICAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgX3RoaXMub25Ub3VjaFBhbm5pbmdTdG9wLCBwYXNzaXZlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjZW50ZXJPbkluaXQgPSBfdGhpcy5zZXR1cC5jZW50ZXJPbkluaXQ7XG4gICAgICAgICAgICBfdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKCk7XG4gICAgICAgICAgICBfdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgaWYgKGNlbnRlck9uSW5pdCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaGFzIHRvIGJlIHJlZG9uZSBvbmNlIHRoZSByaWdodCBzb2x1dGlvbiBpcyBmb3VuZFxuICAgICAgICAgICAgICAgIC8vIHByb2JsZW0gaXMgLSB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgYWZ0ZXIgbW91bnRlZCBjb21wb25lbnQgc3BlY2lmeSBpdCdzIGhlaWdodCAvIHdpZHRoLCBpbWFnZXMgYXJlIGZldGNoZWQgYXN5bmMgc28gaXQncyB0cmlja3lcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldENlbnRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0Q2VudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0Q2VudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLy8vLy8vLy8vXG4gICAgICAgIC8vIFpvb21cbiAgICAgICAgLy8vLy8vLy8vL1xuICAgICAgICBfdGhpcy5vbldoZWVsWm9vbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gX3RoaXMuc2V0dXAuZGlzYWJsZWQ7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGlzV2hlZWxBbGxvd2VkKF90aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIga2V5c1ByZXNzZWQgPSBfdGhpcy5pc1ByZXNzaW5nS2V5cyhfdGhpcy5zZXR1cC53aGVlbC5hY3RpdmF0aW9uS2V5cyk7XG4gICAgICAgICAgICBpZiAoIWtleXNQcmVzc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZVdoZWVsU3RhcnQoX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGhhbmRsZVdoZWVsWm9vbShfdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaGFuZGxlV2hlZWxTdG9wKF90aGlzLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vLy8vLy8vLy9cbiAgICAgICAgLy8gUGFuXG4gICAgICAgIC8vLy8vLy8vLy9cbiAgICAgICAgX3RoaXMub25QYW5uaW5nU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IF90aGlzLnNldHVwLmRpc2FibGVkO1xuICAgICAgICAgICAgdmFyIG9uUGFubmluZ1N0YXJ0ID0gX3RoaXMucHJvcHMub25QYW5uaW5nU3RhcnQ7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGlzUGFubmluZ1N0YXJ0QWxsb3dlZChfdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGtleXNQcmVzc2VkID0gX3RoaXMuaXNQcmVzc2luZ0tleXMoX3RoaXMuc2V0dXAucGFubmluZy5hY3RpdmF0aW9uS2V5cyk7XG4gICAgICAgICAgICBpZiAoIWtleXNQcmVzc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbEFuaW1hdGlvbihfdGhpcyk7XG4gICAgICAgICAgICBoYW5kbGVQYW5uaW5nU3RhcnQoX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25QYW5uaW5nU3RhcnQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblBhbm5pbmcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IF90aGlzLnNldHVwLmRpc2FibGVkO1xuICAgICAgICAgICAgdmFyIG9uUGFubmluZyA9IF90aGlzLnByb3BzLm9uUGFubmluZztcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gaXNQYW5uaW5nQWxsb3dlZChfdGhpcyk7XG4gICAgICAgICAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIga2V5c1ByZXNzZWQgPSBfdGhpcy5pc1ByZXNzaW5nS2V5cyhfdGhpcy5zZXR1cC5wYW5uaW5nLmFjdGl2YXRpb25LZXlzKTtcbiAgICAgICAgICAgIGlmICgha2V5c1ByZXNzZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgaGFuZGxlUGFubmluZyhfdGhpcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgZXZlbnQsIG9uUGFubmluZyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uUGFubmluZ1N0b3AgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBvblBhbm5pbmdTdG9wID0gX3RoaXMucHJvcHMub25QYW5uaW5nU3RvcDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc1Bhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVQYW5uaW5nRW5kKF90aGlzKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgZXZlbnQsIG9uUGFubmluZ1N0b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLy8vLy8vLy8vXG4gICAgICAgIC8vIFBpbmNoXG4gICAgICAgIC8vLy8vLy8vLy9cbiAgICAgICAgX3RoaXMub25QaW5jaFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBfdGhpcy5zZXR1cC5kaXNhYmxlZDtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBvblBpbmNoaW5nU3RhcnQgPSBfYS5vblBpbmNoaW5nU3RhcnQsIG9uWm9vbVN0YXJ0ID0gX2Eub25ab29tU3RhcnQ7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGlzUGluY2hTdGFydEFsbG93ZWQoX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZVBpbmNoU3RhcnQoX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbEFuaW1hdGlvbihfdGhpcyk7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgZXZlbnQsIG9uUGluY2hpbmdTdGFydCk7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgZXZlbnQsIG9uWm9vbVN0YXJ0KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25QaW5jaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gX3RoaXMuc2V0dXAuZGlzYWJsZWQ7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgb25QaW5jaGluZyA9IF9hLm9uUGluY2hpbmcsIG9uWm9vbSA9IF9hLm9uWm9vbTtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gaXNQaW5jaEFsbG93ZWQoX3RoaXMpO1xuICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgaGFuZGxlUGluY2hab29tKF90aGlzLCBldmVudCk7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgZXZlbnQsIG9uUGluY2hpbmcpO1xuICAgICAgICAgICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChfdGhpcyksIGV2ZW50LCBvblpvb20pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblBpbmNoU3RvcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIG9uUGluY2hpbmdTdG9wID0gX2Eub25QaW5jaGluZ1N0b3AsIG9uWm9vbVN0b3AgPSBfYS5vblpvb21TdG9wO1xuICAgICAgICAgICAgaWYgKF90aGlzLnBpbmNoU3RhcnRTY2FsZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZVBpbmNoU3RvcChfdGhpcyk7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChfdGhpcyksIGV2ZW50LCBvblBpbmNoaW5nU3RvcCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChfdGhpcyksIGV2ZW50LCBvblpvb21TdG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8vLy8vLy8vL1xuICAgICAgICAvLyBUb3VjaFxuICAgICAgICAvLy8vLy8vLy8vXG4gICAgICAgIF90aGlzLm9uVG91Y2hQYW5uaW5nU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IF90aGlzLnNldHVwLmRpc2FibGVkO1xuICAgICAgICAgICAgdmFyIG9uUGFubmluZ1N0YXJ0ID0gX3RoaXMucHJvcHMub25QYW5uaW5nU3RhcnQ7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGlzUGFubmluZ1N0YXJ0QWxsb3dlZChfdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlzRG91YmxlVGFwID0gX3RoaXMubGFzdFRvdWNoICYmICtuZXcgRGF0ZSgpIC0gX3RoaXMubGFzdFRvdWNoIDwgMjAwO1xuICAgICAgICAgICAgaWYgKGlzRG91YmxlVGFwICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25Eb3VibGVDbGljayhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0VG91Y2ggPSArbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVDYW5jZWxBbmltYXRpb24oX3RoaXMpO1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcztcbiAgICAgICAgICAgICAgICB2YXIgaXNQYW5uaW5nQWN0aW9uID0gdG91Y2hlcy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICAgICAgdmFyIGlzUGluY2hBY3Rpb24gPSB0b3VjaGVzLmxlbmd0aCA9PT0gMjtcbiAgICAgICAgICAgICAgICBpZiAoaXNQYW5uaW5nQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUNhbmNlbEFuaW1hdGlvbihfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVBhbm5pbmdTdGFydChfdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgZXZlbnQsIG9uUGFubmluZ1N0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzUGluY2hBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25QaW5jaFN0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uVG91Y2hQYW5uaW5nID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBfdGhpcy5zZXR1cC5kaXNhYmxlZDtcbiAgICAgICAgICAgIHZhciBvblBhbm5pbmcgPSBfdGhpcy5wcm9wcy5vblBhbm5pbmc7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNQYW5uaW5nICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGlzUGFubmluZ0FsbG93ZWQoX3RoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgIGhhbmRsZVBhbm5pbmcoX3RoaXMsIHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25QYW5uaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uUGluY2goZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblRvdWNoUGFubmluZ1N0b3AgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLm9uUGFubmluZ1N0b3AoZXZlbnQpO1xuICAgICAgICAgICAgX3RoaXMub25QaW5jaFN0b3AoZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvLy8vLy8vLy8vXG4gICAgICAgIC8vIERvdWJsZSBDbGlja1xuICAgICAgICAvLy8vLy8vLy8vXG4gICAgICAgIF90aGlzLm9uRG91YmxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IF90aGlzLnNldHVwLmRpc2FibGVkO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSBpc0RvdWJsZUNsaWNrQWxsb3dlZChfdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaGFuZGxlRG91YmxlQ2xpY2soX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8vLy8vLy8vL1xuICAgICAgICAvLyBIZWxwZXJzXG4gICAgICAgIC8vLy8vLy8vLy9cbiAgICAgICAgX3RoaXMuY2xlYXJQYW5uaW5nID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNQYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25QYW5uaW5nU3RvcChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldEtleVByZXNzZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMucHJlc3NlZEtleXNbZS5rZXldID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0S2V5VW5QcmVzc2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLnByZXNzZWRLZXlzW2Uua2V5XSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1ByZXNzaW5nS2V5cyA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihrZXlzLmZpbmQoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gX3RoaXMucHJlc3NlZEtleXNba2V5XTsgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRDb21wb25lbnRzID0gZnVuY3Rpb24gKHdyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIF90aGlzLndyYXBwZXJDb21wb25lbnQgPSB3cmFwcGVyQ29tcG9uZW50O1xuICAgICAgICAgICAgX3RoaXMuY29udGVudENvbXBvbmVudCA9IGNvbnRlbnRDb21wb25lbnQ7XG4gICAgICAgICAgICBoYW5kbGVDYWxjdWxhdGVCb3VuZHMoX3RoaXMsIF90aGlzLnRyYW5zZm9ybVN0YXRlLnNjYWxlKTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZUluaXRpYWxpemVXcmFwcGVyRXZlbnRzKHdyYXBwZXJDb21wb25lbnQpO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlSW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlUmVmKCk7XG4gICAgICAgICAgICBfdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCB1bmRlZmluZWQsIF90aGlzLnByb3BzLm9uSW5pdCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldFRyYW5zZm9ybVN0YXRlID0gZnVuY3Rpb24gKHNjYWxlLCBwb3NpdGlvblgsIHBvc2l0aW9uWSkge1xuICAgICAgICAgICAgaWYgKCFpc05hTihzY2FsZSkgJiYgIWlzTmFOKHBvc2l0aW9uWCkgJiYgIWlzTmFOKHBvc2l0aW9uWSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NhbGUgIT09IF90aGlzLnRyYW5zZm9ybVN0YXRlLnNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyYW5zZm9ybVN0YXRlLnByZXZpb3VzU2NhbGUgPSBfdGhpcy50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJhbnNmb3JtU3RhdGUuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhbnNmb3JtU3RhdGUucG9zaXRpb25YID0gcG9zaXRpb25YO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyYW5zZm9ybVN0YXRlLnBvc2l0aW9uWSA9IHBvc2l0aW9uWTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRGV0ZWN0ZWQgTmFOIHNldCBzdGF0ZSB2YWx1ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy53cmFwcGVyQ29tcG9uZW50ICYmIF90aGlzLmNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0U3RhdGUgPSBnZXRDZW50ZXJQb3NpdGlvbihfdGhpcy50cmFuc2Zvcm1TdGF0ZS5zY2FsZSwgX3RoaXMud3JhcHBlckNvbXBvbmVudCwgX3RoaXMuY29udGVudENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0VHJhbnNmb3JtU3RhdGUodGFyZ2V0U3RhdGUuc2NhbGUsIHRhcmdldFN0YXRlLnBvc2l0aW9uWCwgdGFyZ2V0U3RhdGUucG9zaXRpb25ZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMubW91bnRlZCB8fCAhX3RoaXMuY29udGVudENvbXBvbmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy50cmFuc2Zvcm1TdGF0ZSwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtU3R5bGVzKHBvc2l0aW9uWCwgcG9zaXRpb25ZLCBzY2FsZSk7XG4gICAgICAgICAgICBfdGhpcy5jb250ZW50Q29tcG9uZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVJlZigpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5zZXRSZWYoZ2V0Q29udGV4dChfdGhpcykpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRyYW5zZm9ybUNvbnRleHQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFzc2l2ZSA9IG1ha2VQYXNzaXZlRXZlbnRPcHRpb24oKTtcbiAgICAgICAgLy8gUGFubmluZyBvbiB3aW5kb3cgdG8gYWxsb3cgcGFubmluZyB3aGVuIG1vdXNlIGlzIG91dCBvZiBjb21wb25lbnQgd3JhcHBlclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uUGFubmluZ1N0YXJ0LCBwYXNzaXZlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5vblBhbm5pbmcsIHBhc3NpdmUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5vblBhbm5pbmdTdG9wLCBwYXNzaXZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5jbGVhclBhbm5pbmcsIHBhc3NpdmUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuc2V0S2V5VW5QcmVzc2VkLCBwYXNzaXZlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuc2V0S2V5UHJlc3NlZCwgcGFzc2l2ZSk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVmKCk7XG4gICAgfTtcbiAgICBUcmFuc2Zvcm1Db250ZXh0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhc3NpdmUgPSBtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uKCk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMub25QYW5uaW5nU3RhcnQsIHBhc3NpdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uUGFubmluZywgcGFzc2l2ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLm9uUGFubmluZ1N0b3AsIHBhc3NpdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuc2V0S2V5VW5QcmVzc2VkLCBwYXNzaXZlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuc2V0S2V5UHJlc3NlZCwgcGFzc2l2ZSk7XG4gICAgICAgIGhhbmRsZUNhbmNlbEFuaW1hdGlvbih0aGlzKTtcbiAgICB9O1xuICAgIFRyYW5zZm9ybUNvbnRleHQucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChvbGRQcm9wcykge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IHRoaXMucHJvcHMpIHtcbiAgICAgICAgICAgIGhhbmRsZUNhbGN1bGF0ZUJvdW5kcyh0aGlzLCB0aGlzLnRyYW5zZm9ybVN0YXRlLnNjYWxlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0dXAgPSBjcmVhdGVTZXR1cCh0aGlzLnByb3BzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNmb3JtQ29udGV4dC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBnZXRDb250ZXh0KHRoaXMpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgY29udGVudCA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4odmFsdWUpIDogY2hpbGRyZW47XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy50cmFuc2Zvcm1TdGF0ZSksIHsgc2V0Q29tcG9uZW50czogdGhpcy5zZXRDb21wb25lbnRzLCBjb250ZXh0SW5zdGFuY2U6IHRoaXMgfSkgfSwgY29udGVudCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zZm9ybUNvbnRleHQ7XG59KENvbXBvbmVudCkpO1xuXG52YXIgVHJhbnNmb3JtV3JhcHBlciA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgICB2YXIgX2EgPSB1c2VTdGF0ZShudWxsKSwgaW5uZXJSZWYgPSBfYVswXSwgc2V0UmVmID0gX2FbMV07XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlubmVyUmVmOyB9LCBbaW5uZXJSZWZdKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUcmFuc2Zvcm1Db250ZXh0LCBfX2Fzc2lnbih7fSwgcHJvcHMsIHsgc2V0UmVmOiBzZXRSZWYgfSkpO1xufSk7XG5cbmZ1bmN0aW9uIHN0eWxlSW5qZWN0KGNzcywgcmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGluc2VydEF0ID0gcmVmLmluc2VydEF0O1xuXG4gIGlmICghY3NzIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIGNzc18yNDh6ID0gXCIudHJhbnNmb3JtLWNvbXBvbmVudC1tb2R1bGVfd3JhcHBlcl9fMV9GZ2oge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IC1tb3otZml0LWNvbnRlbnQ7XFxuICB3aWR0aDogZml0LWNvbnRlbnQ7XFxuICBoZWlnaHQ6IC1tb3otZml0LWNvbnRlbnQ7XFxuICBoZWlnaHQ6IGZpdC1jb250ZW50O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTsgLyogaU9TIFNhZmFyaSAqL1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLyogU2FmYXJpICovXFxuICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEtvbnF1ZXJvciBIVE1MICovXFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lOyAvKiBGaXJlZm94ICovXFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEludGVybmV0IEV4cGxvcmVyL0VkZ2UgKi9cXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuLnRyYW5zZm9ybS1jb21wb25lbnQtbW9kdWxlX2NvbnRlbnRfXzJqWWdoIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxuICB3aWR0aDogLW1vei1maXQtY29udGVudDtcXG4gIHdpZHRoOiBmaXQtY29udGVudDtcXG4gIGhlaWdodDogLW1vei1maXQtY29udGVudDtcXG4gIGhlaWdodDogZml0LWNvbnRlbnQ7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgdHJhbnNmb3JtLW9yaWdpbjogMCUgMCU7XFxufVxcbi50cmFuc2Zvcm0tY29tcG9uZW50LW1vZHVsZV9jb250ZW50X18yallnaCBpbWcge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblwiO1xudmFyIHN0eWxlcyA9IHtcIndyYXBwZXJcIjpcInRyYW5zZm9ybS1jb21wb25lbnQtbW9kdWxlX3dyYXBwZXJfXzFfRmdqXCIsXCJjb250ZW50XCI6XCJ0cmFuc2Zvcm0tY29tcG9uZW50LW1vZHVsZV9jb250ZW50X18yallnaFwifTtcbnN0eWxlSW5qZWN0KGNzc18yNDh6KTtcblxudmFyIFRyYW5zZm9ybUNvbXBvbmVudCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBfYiA9IF9hLndyYXBwZXJDbGFzcywgd3JhcHBlckNsYXNzID0gX2IgPT09IHZvaWQgMCA/IFwiXCIgOiBfYiwgX2MgPSBfYS5jb250ZW50Q2xhc3MsIGNvbnRlbnRDbGFzcyA9IF9jID09PSB2b2lkIDAgPyBcIlwiIDogX2MsIHdyYXBwZXJTdHlsZSA9IF9hLndyYXBwZXJTdHlsZSwgY29udGVudFN0eWxlID0gX2EuY29udGVudFN0eWxlO1xuICAgIHZhciBzZXRDb21wb25lbnRzID0gdXNlQ29udGV4dChDb250ZXh0KS5zZXRDb21wb25lbnRzO1xuICAgIHZhciB3cmFwcGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHZhciBjb250ZW50UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gd3JhcHBlclJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgY29udGVudCA9IGNvbnRlbnRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHdyYXBwZXIgIT09IG51bGwgJiYgY29udGVudCAhPT0gbnVsbCAmJiBzZXRDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBzZXRDb21wb25lbnRzKHdyYXBwZXIsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogd3JhcHBlclJlZiwgY2xhc3NOYW1lOiBcInJlYWN0LXRyYW5zZm9ybS13cmFwcGVyIFwiICsgc3R5bGVzLndyYXBwZXIgKyBcIiBcIiArIHdyYXBwZXJDbGFzcywgc3R5bGU6IHdyYXBwZXJTdHlsZSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBjb250ZW50UmVmLCBjbGFzc05hbWU6IFwicmVhY3QtdHJhbnNmb3JtLWNvbXBvbmVudCBcIiArIHN0eWxlcy5jb250ZW50ICsgXCIgXCIgKyBjb250ZW50Q2xhc3MsIHN0eWxlOiBjb250ZW50U3R5bGUgfSwgY2hpbGRyZW4pKSk7XG59O1xuXG52YXIgdXNlVHJhbnNmb3JtQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGlicmFyeUNvbnRleHQgPSB1c2VDb250ZXh0KENvbnRleHQpO1xuICAgIGlmICghbGlicmFyeUNvbnRleHQuY29udGV4dEluc3RhbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zZm9ybSBjb250ZXh0IG11cyBiZSBwbGFjZWQgaW5zaWRlIFRyYW5zZm9ybVdyYXBwZXJcIik7XG4gICAgfVxuICAgIHJldHVybiBnZXRDb250ZXh0KGxpYnJhcnlDb250ZXh0LmNvbnRleHRJbnN0YW5jZSk7XG59O1xuXG5leHBvcnQgeyBUcmFuc2Zvcm1Db21wb25lbnQsIFRyYW5zZm9ybVdyYXBwZXIsIHVzZVRyYW5zZm9ybUNvbnRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-zoom-pan-pinch/dist/index.esm.js\n");

/***/ })

}]);