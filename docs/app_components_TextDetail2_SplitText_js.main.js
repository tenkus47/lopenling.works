/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkteminusclient"] = self["webpackChunkteminusclient"] || []).push([["app_components_TextDetail2_SplitText_js"],{

/***/ "./app/components/TextDetail2/SplitText.js":
/*!*************************************************!*\
  !*** ./app/components/TextDetail2/SplitText.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SplitTextComponent)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_virtualized_dist_es_AutoSizer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-virtualized/dist/es/AutoSizer */ \"./node_modules/react-virtualized/dist/es/AutoSizer/index.js\");\n/* harmony import */ var react_virtualized__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-virtualized */ \"./node_modules/react-virtualized/dist/es/index.js\");\n/* harmony import */ var react_virtualized_dist_es_CellMeasurer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-virtualized/dist/es/CellMeasurer */ \"./node_modules/react-virtualized/dist/es/CellMeasurer/index.js\");\n/* harmony import */ var react_virtualized_styles_css__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! react-virtualized/styles.css */ \"./node_modules/react-virtualized/styles.css\");\n/* harmony import */ var react_virtualized_styles_css__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(react_virtualized_styles_css__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var _Text2__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Text2 */ \"./app/components/TextDetail2/Text2.js\");\n/* harmony import */ var lib_SplitText__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lib/SplitText */ \"./app/lib/SplitText.js\");\n/* harmony import */ var _SplitText_css__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./SplitText.css */ \"./app/components/TextDetail2/SplitText.css\");\n/* harmony import */ var _SplitText_css__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_SplitText_css__WEBPACK_IMPORTED_MODULE_16__);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_17__);\n/* harmony import */ var lib_TextSegment__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! lib/TextSegment */ \"./app/lib/TextSegment.js\");\n/* harmony import */ var lib_Witness__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! lib/Witness */ \"./app/lib/Witness.js\");\n/* harmony import */ var grapheme_splitter__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! grapheme-splitter */ \"./node_modules/grapheme-splitter/index.js\");\n/* harmony import */ var grapheme_splitter__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(grapheme_splitter__WEBPACK_IMPORTED_MODULE_20__);\n\n\n\n\n\n\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar _searchResultsCache = {};\n\nvar SplitTextComponent = /*#__PURE__*/function (_React$PureComponent) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(SplitTextComponent, _React$PureComponent);\n\n  var _super = _createSuper(SplitTextComponent);\n\n  // Whether the mouse button is down\n  function SplitTextComponent(props) {\n    var _this;\n\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, SplitTextComponent);\n\n    _this = _super.call(this, props);\n    _this.textAlignmentById = [];\n    _this.changeScrollToId = props.changeScrollToId;\n    _this.list = null;\n    _this.splitText = null;\n    _this.cache = new react_virtualized_dist_es_CellMeasurer__WEBPACK_IMPORTED_MODULE_12__.CellMeasurerCache({\n      fixedWidth: true\n    });\n    _this.rowRenderer = _this.rowRenderer.bind((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(_this));\n    _this.isPanelLinked = _this.props.isPanelLinked;\n    _this.activeSelection = null;\n    _this.selectedNodes = null;\n    _this._mouseDown = false;\n    _this._activeWitness = null;\n    _this._didSetInitialScrollPosition = false;\n    _this._modifyingSelection = false;\n    _this.imageHeight = null;\n    _this.imageWidth = null;\n    _this.calculatedImageHeight = null;\n    _this.selectedWindow = _this.props.selectedWindow;\n    _this.scrollEvent = _this.scrollEvent.bind((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(_this)); // this.processProps(props);\n\n    _this.scrollTop = 0;\n    return _this;\n  }\n\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(SplitTextComponent, [{\n    key: \"scrollEvent\",\n    value: function scrollEvent(e) {\n      if (this.selectedWindow === 1) return null;\n\n      if (this.selectedWindow === 2 && this.isPanelLinked) {\n        var list = [];\n        this.textAlignmentById.map(function (l) {\n          var number = document.getElementById(\"s2_\" + l.TStart);\n\n          if (number) {\n            var _position = number.getBoundingClientRect();\n\n            if (_position.top > 90) {\n              list.push({\n                id: l.id,\n                start: l.start,\n                TStart: l.TStart,\n                end: l.end,\n                TEnd: l.TEnd\n              });\n            }\n          }\n        });\n\n        if (!lodash__WEBPACK_IMPORTED_MODULE_17___default().isEmpty(list)) {\n          if (this.selectedWindow === 2) {\n            this.debouncedScroll(list);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"selectedListRow\",\n    value: function selectedListRow(props) {\n      var row = null;\n\n      if (props.activeAnnotation) {\n        row = props.splitText.getTextIndexOfPosition(props.activeAnnotation.start);\n      }\n\n      return row;\n    }\n  }, {\n    key: \"handleSelection\",\n    value: function handleSelection(e) {\n      if (!this._modifyingSelection) {\n        this.activeSelection = document.getSelection();\n\n        if (!this._mouseDown) {\n          // sometimes, this gets called after the mouseDown event handler\n          this.mouseUp();\n        }\n      } else {\n        e.stopPropagation(); // Need to set this here. If set at callsite, the event will not\n        // have time to propagate.\n\n        this._modifyingSelection = false;\n      }\n    }\n  }, {\n    key: \"mouseDown\",\n    value: function mouseDown() {\n      this._mouseDown = true;\n    }\n  }, {\n    key: \"mouseUp\",\n    value: function mouseUp() {\n      this._mouseDown = false;\n\n      if (this.activeSelection) {\n        // let segmentIds = this.processSelection(this.activeSelection);\n        // if (!segmentIds) {\n        //     segmentIds = [];\n        // }\n        // this.props.didSelectSegmentIds(segmentIds);\n        this.activeSelection = null;\n      }\n    } // processSelection(selection: Selection): string[] | null {\n    //     if (\n    //         selection.rangeCount === 0 ||\n    //         selection.isCollapsed ||\n    //         selection.type === \"Caret\"\n    //     ) {\n    //         this.selectedNodes = null;\n    //         return null;\n    //     }\n    //     const range = selection.getRangeAt(0);\n    //     const start = range.startContainer;\n    //     const startSpan = this.getNodeSegmentSpan(start);\n    //     if (!(startSpan && startSpan.parentNode)) {\n    //         If the selection is not a text segment, ignore.\n    //         Assuming if the first node is a non-segment, they\n    //         all are.\n    //         return null;\n    //     }\n    //     let nodes = this.getRangeNodes(range, startSpan.parentNode);\n    //     Check if the selection starts after the end of a node, and\n    //     if so remove that node.\n    //     if (nodes.length > 0) {\n    //         let firstNode = nodes[0];\n    //         if (range.startOffset === firstNode.textContent.length) {\n    //             nodes.shift();\n    //         }\n    //     }\n    //     const end = range.endContainer;\n    //     const endSpan = this.getNodeSegmentSpan(end);\n    //     if (!(endSpan && endSpan.parentNode)) {\n    //         return null;\n    //     }\n    //     if (endSpan && startSpan.parentNode !== endSpan.parentNode) {\n    //         Selection is spanning Texts.\n    //         We assume a selection can only run across a maximum\n    //         of two Texts.\n    //         nodes = nodes.concat(this.getRangeNodes(range, endSpan.parentNode));\n    //     } else {\n    //         Check if the selection ends before the start of a node, and\n    //         if so remove that node.\n    //         if (range.endOffset === 0) {\n    //             nodes.pop();\n    //         }\n    //     }\n    //     this.selectedNodes = nodes;\n    //     let nodeIds = [];\n    //     nodes.reduce((accumulator: string[], current: Node) => {\n    //         if (current instanceof Element) {\n    //             accumulator.push(current.id);\n    //         }\n    //         return accumulator;\n    //     }, nodeIds);\n    //     return nodeIds;\n    // }\n    // getRangeNodes(range: Range, parentNode: Node): Node[] {\n    //     let rangeSpans = [];\n    //     for (let i = 0, len = parentNode.childNodes.length; i < len; i++) {\n    //         const node = parentNode.childNodes[i];\n    //         // TODO: add polyfill for i.e.?\n    //         // e.g. https://gist.github.com/jonathansampson/6d09bd6d2e8c22c53868aec42e66b0f9\n    //         if (range.intersectsNode(node)) {\n    //             rangeSpans.push(node);\n    //         }\n    //     }\n    //     return rangeSpans;\n    // }\n\n  }, {\n    key: \"getNodeSegmentSpan\",\n    value: function getNodeSegmentSpan(node) {\n      var currentNode = node;\n      var span = null;\n      var test = /^(i|s|ds)_/;\n\n      while (!span && currentNode.parentNode) {\n        if (currentNode instanceof Element && test.test(currentNode.id)) {\n          span = currentNode;\n        }\n\n        currentNode = currentNode.parentNode;\n      }\n\n      return span;\n    }\n  }, {\n    key: \"updateList\",\n    value: function updateList() {\n      var resetCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var resetRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (this.props.showImages && !this.calculatedImageHeight && this.imageHeight && this.imageWidth) {\n        this.calculatedImageHeight = this.calculateImageHeight();\n      }\n\n      if (this.list) {\n        var list = this.list;\n\n        if (resetCache) {\n          if (resetRows !== null) {\n            if (!Array.isArray(resetRows)) {\n              this.cache.clear(resetRows);\n            } else if (Array.isArray(resetRows)) {\n              for (var i = 0; i < resetRows.length; i++) {\n                var resetRow = resetRows[i];\n                this.cache.clear(resetRow);\n              }\n            }\n          } else {\n            this.cache.clearAll();\n            list.measureAllRows();\n            list.recomputeRowHeights(0);\n          }\n        }\n\n        list.forceUpdateGrid();\n      }\n    }\n  }, {\n    key: \"processProps\",\n    value: function processProps(props) {\n      var _this2 = this;\n\n      var changedWitness = false;\n\n      if (!this.props.selectedWitness || props.selectedWitness && props.selectedWitness.id !== this.props.selectedWitness.id) {\n        changedWitness = true;\n        this._didSetInitialScrollPosition = false;\n      }\n\n      if (props.selectedSearchResult && (!this.props.selectedSearchResult || props.selectedSearchResult.start !== this.props.selectedSearchResult.start || props.selectedSearchResult.textId !== this.props.selectedSearchResult.textId)) {\n        console.log(\"resetting scroll position from search result\");\n        this._didSetInitialScrollPosition = false;\n      } // TODO: check if new selectedSearchResult and if so\n      // set this._didSetInitialScrollPosition = false\n      // make sure there's no numbers in selectedAnnotatedSegments\n      // as we want to pass it to Text which only expects TextSegments\n      // this._filteredSelectedAnnotatedSegments = props.selectedAnnotatedSegments.reduce(\n      //     (acc, current: TextSegment | number) => {\n      //         if (current instanceof TextSegment) acc.push(current);\n      //         return acc;\n      //     },\n      //     []\n      // );\n\n\n      var controlsMeasurements = this.getControlsMeasurements(props);\n\n      if (controlsMeasurements) {\n        this.selectedTextIndex = controlsMeasurements.selectedTextIndex;\n        this.firstSelectedSegment = controlsMeasurements.firstSelectedSegment;\n        this.splitTextRect = controlsMeasurements.splitTextRect;\n        this.selectedElementId = controlsMeasurements.selectedElementId;\n        this.selectedElementIds = controlsMeasurements.selectedElementIds;\n      }\n\n      if (props.textListVisible !== this.textListVisible || props.editMenuVisible !== this.editMenuVisible) {\n        setTimeout(function () {\n          _this2.textListVisible = props.textListVisible;\n          _this2.editMenuVisible = props.editMenuVisible;\n\n          _this2.updateList(true);\n        }, 500);\n      } else {\n        if (changedWitness) {\n          this.updateList(true);\n        } else if (this.pageBreaksChanged(this.props, props)) {\n          var selectedRows = null;\n          var currentSelectedRow = this.selectedListRow(this.props);\n          var newSelectedRow = this.selectedListRow(props);\n\n          if (currentSelectedRow && newSelectedRow) {\n            var firstChangedRow = currentSelectedRow > newSelectedRow ? newSelectedRow : currentSelectedRow;\n            var splitRowTexts = this.props.splitText.texts;\n            selectedRows = [];\n\n            for (var i = firstChangedRow, len = splitRowTexts.length; i < len; i++) {\n              selectedRows.push(i);\n            }\n          }\n\n          this.updateList(true, selectedRows);\n        } else if (this.lineBreaksChanges(this.props, props)) {\n          var selectedRow = this.selectedListRow(props);\n          if (!selectedRow) selectedRow = this.selectedListRow(this.props);\n          var _splitRowTexts = this.props.splitText.texts;\n          var _selectedRows = [];\n\n          if (selectedRow !== null) {\n            for (var _i = selectedRow, _len = _splitRowTexts.length; _i < _len; _i++) {\n              _selectedRows.push(_i);\n            }\n\n            this.updateList(true, _selectedRows);\n          }\n        } else if (this.props.fontSize !== props.fontSize) {\n          this.updateList(true);\n        } else if (this.props.activeAnnotation && props.activeAnnotation && this.annotationsInSameLocation(this.props.activeAnnotation, props.activeAnnotation)) {\n          this.updateList(true, this.selectedListRow(props));\n        } else {\n          this.updateList(this.shouldResetListCache(this.props, props));\n        }\n      }\n    }\n  }, {\n    key: \"pageBreaksChanged\",\n    value: function pageBreaksChanged(oldProps, newProps) {\n      var oldTextBreaks = oldProps.splitText.getTextsFinalPositions();\n      var newTextBreaks = newProps.splitText.getTextsFinalPositions();\n      if (oldTextBreaks.length !== newTextBreaks.length) return true;\n      return JSON.stringify(oldTextBreaks) !== JSON.stringify(newTextBreaks);\n    }\n  }, {\n    key: \"lineBreaksChanges\",\n    value: function lineBreaksChanges(oldProps, newProps) {\n      var oldActiveAnnotation = oldProps.activeAnnotation;\n      var newActiveAnnotation = newProps.activeAnnotation;\n      var hasChanged = false;\n\n      if (oldActiveAnnotation && oldActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) && newProps.activeAnnotations && !newProps.activeAnnotations.hasOwnProperty(oldActiveAnnotation.uniqueId)) {\n        hasChanged = true;\n      }\n\n      if (newActiveAnnotation && newActiveAnnotation.isType(ANNOTATION_TYPES.lineBreak) && oldProps.activeAnnotations && !oldProps.activeAnnotations.hasOwnProperty(newActiveAnnotation.uniqueId)) {\n        hasChanged = true;\n      }\n\n      return hasChanged;\n    }\n  }, {\n    key: \"shouldResetListCache\",\n    value: function shouldResetListCache(oldProps, newProps) {\n      var shouldReset = false;\n\n      if (oldProps.showImages !== newProps.showImages || this.pageBreaksChanged(oldProps, newProps)) {\n        shouldReset = true;\n      }\n\n      return shouldReset;\n    }\n  }, {\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(props) {\n      this.processProps(props);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this3 = this;\n\n      this.resizeHandler = lodash__WEBPACK_IMPORTED_MODULE_17___default().throttle(function () {\n        _this3.calculatedImageHeight = null;\n\n        _this3.updateList();\n      }, 500).bind(this);\n      window.addEventListener(\"resize\", this.resizeHandler);\n      this.debouncedScroll = lodash__WEBPACK_IMPORTED_MODULE_17___default().debounce(function (list) {\n        _this3.changeScrollToId({\n          id: list[0].TStart,\n          from: 2\n        });\n      }, 1000);\n      this.selectionHandler = lodash__WEBPACK_IMPORTED_MODULE_17___default().debounce(function (e) {\n        _this3.handleSelection(e);\n      }, 200).bind(this);\n      document.addEventListener(\"selectionchange\", this.selectionHandler);\n      document.addEventListener(\"mousedown\", this.mouseDown.bind(this), true);\n      document.addEventListener(\"mouseup\", this.mouseUp.bind(this), true);\n      this.processProps(this.props);\n      this.componentDidUpdate();\n      this.timer = setTimeout(function () {\n        _this3.resizeHandler();\n      }, 2000);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _Alignment$target,\n          _this$props,\n          _this$props2,\n          _this4 = this;\n\n      var scrollToId = this.props.scrollToId;\n      this.targetId2 = this.props.syncIdOnClick;\n      this.isPanelLinked = this.props.isPanelLinked;\n      this.selectedWindow = this.props.selectedWindow;\n      var SearchSyncId = this.props.syncIdOnSearch || null;\n      var list = this.list;\n      var result = this.props.searchResults;\n      var Alignment = this.props.textAlignment;\n      this.condition = (Alignment === null || Alignment === void 0 ? void 0 : (_Alignment$target = Alignment.target) === null || _Alignment$target === void 0 ? void 0 : _Alignment$target.witness) === this.props.selectedWitness.id;\n      var con = (prevProps === null || prevProps === void 0 ? void 0 : prevProps.searchResults) !== ((_this$props = this.props) === null || _this$props === void 0 ? void 0 : _this$props.searchResults) || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.syncIdOnSearch) !== ((_this$props2 = this.props) === null || _this$props2 === void 0 ? void 0 : _this$props2.syncIdOnSearch); // for scrolling for search results;\n\n      if (con && result) {\n        if (SearchSyncId) {\n          var selectedTextIndex = this.props.splitText.getTextIndexOfPosition(SearchSyncId);\n          setTimeout(function () {\n            list.scrollToRow(selectedTextIndex);\n            setTimeout(function () {\n              list.scrollToPosition(list.props.scrollTop - 300);\n            }, 0);\n          }, 100);\n        }\n      } //for scrolling to id aligned with first window\n      //scroll control linked\n\n\n      if (this.selectedWindow === 1 && scrollToId.from === 1 && this.isPanelLinked && this.condition && scrollToId.id !== null) {\n        var _list = this.list;\n        this.textAlignmentById = this.props.textAlignmentById || [];\n        this.splitText.style.scrollBehavior = \"smooth\";\n\n        if (Alignment && this.isPanelLinked) {\n          var req = this.textAlignmentById.find(function (l) {\n            return l.start === scrollToId.id;\n          });\n          var TStart = req === null || req === void 0 ? void 0 : req.TStart;\n\n          if (TStart !== null) {\n            var _selectedTextIndex = this.props.splitText.getTextIndexOfPosition(TStart);\n\n            setTimeout(function () {\n              _list.scrollToRow(_selectedTextIndex);\n\n              setTimeout(function () {\n                _list.scrollToPosition(_list.props.scrollTop - 300);\n              }, 0);\n            }, 100);\n          }\n        }\n      } //for scrolling to the highlighted alignment if its outside visible DOM\n\n\n      if (this.isPanelLinked && this.targetId2 && scrollToId.from === null && this.selectedWindow === 1 && scrollToId.id === null && this.condition) {\n        var _clickIdObj$target_se;\n\n        var clickIdObj = Alignment.alignment.find(function (l) {\n          return _this4.targetId2 >= l.source_segment.start && _this4.targetId2 < l.source_segment.end;\n        });\n        var syncClickTargetId = clickIdObj === null || clickIdObj === void 0 ? void 0 : (_clickIdObj$target_se = clickIdObj.target_segment) === null || _clickIdObj$target_se === void 0 ? void 0 : _clickIdObj$target_se.start;\n\n        var _selectedTextIndex2 = this.props.splitText.getTextIndexOfPosition(syncClickTargetId);\n\n        setTimeout(function () {\n          list.scrollToRow(_selectedTextIndex2);\n          setTimeout(function () {\n            list.scrollToPosition(list.props.scrollTop - 300);\n          }, 0);\n        }, 100);\n      } // if (this.selectedNodes && this.selectedNodes.length > 0) {\n      //     const selectedNodes = this.selectedNodes;\n      //     const selectedSegments = this.props.selectedAnnotatedSegments;\n      //     setTimeout(() => {\n      //         let selRange = document.createRange();\n      //         let startNode = selectedNodes[0];\n      //         let endNode = selectedNodes[selectedNodes.length - 1];\n      //         // let lastSegment = selectedSegments[selectedSegments.length - 1];\n      //         if (lastSegment instanceof TextSegment) {\n      //             let lastElement = document.getElementById(\n      //                 idForSegment(lastSegment)\n      //             );\n      //             if (lastElement) endNode = lastElement;\n      //         }\n      //         if (\n      //             startNode instanceof Element &&\n      //             endNode instanceof Element\n      //         ) {\n      //             startNode = document.getElementById(startNode.id);\n      //             endNode = document.getElementById(endNode.id);\n      //             if (startNode && endNode) {\n      //                 selRange.setStart(startNode, 0);\n      //                 selRange.setEnd(endNode, endNode.childNodes.length);\n      //                 let sel = document.getSelection();\n      //                 if (sel) {\n      //                     this._modifyingSelection = true;\n      //                     sel.removeAllRanges();\n      //                     sel.addRange(selRange);\n      //                     this.selectedNodes = null;\n      //                 }\n      //             }\n      //         }\n      //     }, 0);\n      // }\n\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      document.removeEventListener(\"mousedown\", this);\n      document.removeEventListener(\"mouseup\", this);\n      window.removeEventListener(\"resize\", this.resizeHandler);\n      document.removeEventListener(\"selectionchange\", this.selectionHandler);\n      clearTimeout(this.timer);\n    }\n  }, {\n    key: \"getSelectedTextIndex\",\n    value: function getSelectedTextIndex() {\n      var selectedTextIndex = 0;\n      var startPos = null;\n\n      if (this.props.activeAnnotation) {\n        var _this$props$splitText = this.props.splitText.annotatedText.getPositionOfAnnotation(this.props.activeAnnotation);\n\n        var _this$props$splitText2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this$props$splitText, 1);\n\n        startPos = _this$props$splitText2[0];\n      } else if (this.props.selectedSearchResult) {\n        var _segment = this.props.splitText.annotatedText.segmentAtOriginalPosition(this.props.selectedSearchResult.start);\n\n        if (_segment instanceof lib_TextSegment__WEBPACK_IMPORTED_MODULE_18__[\"default\"]) {\n          startPos = _segment.start;\n        } else if (typeof _segment === \"number\") {\n          startPos = _segment;\n        }\n      }\n\n      if (startPos) {\n        selectedTextIndex = this.props.splitText.getTextIndexOfPosition(startPos);\n      }\n\n      return selectedTextIndex;\n    }\n  }, {\n    key: \"getControlsMeasurements\",\n    value: function getControlsMeasurements(props) {\n      if (!this.splitText) {\n        return null;\n      }\n\n      var splitTextComponent = this.splitText;\n      var selectedTextIndex = null;\n      var firstSelectedSegment = null;\n      var selectedElementId = null;\n      var splitTextRect = null;\n      var segmentIdFunction = null;\n      var selectedElementIds = [];\n      var startPos = 0;\n\n      if (props.activeAnnotation) {\n        var activeAnnotation = props.activeAnnotation;\n\n        var _props$splitText$anno = props.splitText.annotatedText.getPositionOfAnnotation(activeAnnotation);\n\n        var _props$splitText$anno2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_props$splitText$anno, 1);\n\n        startPos = _props$splitText$anno2[0];\n\n        if (startPos === null) {\n          console.warn(\"No startPos in getControlsMeasurements\");\n          return null;\n        }\n\n        if (activeAnnotation.type === ANNOTATION_TYPES.pageBreak) {\n          startPos -= 1;\n        }\n\n        if (activeAnnotation.type === ANNOTATION_TYPES.lineBreak) {\n          startPos -= 1;\n        } // Index of text containing end of annotation\n\n\n        var positionEnd = startPos + activeAnnotation.length;\n        if (activeAnnotation.length > 0) positionEnd -= 1;\n        selectedTextIndex = props.splitText.getTextIndexOfPosition(positionEnd);\n        splitTextRect = splitTextComponent.getBoundingClientRect();\n      }\n\n      var selectedAnnotatedSegments = [];\n\n      if (props.selectedAnnotatedSegments && props.selectedAnnotatedSegments.length > 0) {\n        selectedAnnotatedSegments = props.selectedAnnotatedSegments;\n\n        for (var i = 0; i < selectedAnnotatedSegments.length; i++) {\n          var _segment2 = selectedAnnotatedSegments[i];\n\n          if (firstSelectedSegment === null && _segment2 instanceof lib_TextSegment__WEBPACK_IMPORTED_MODULE_18__[\"default\"]) {\n            firstSelectedSegment = _segment2;\n            break;\n          }\n        }\n\n        if (firstSelectedSegment) {\n          if (firstSelectedSegment.length === 0 && props.activeAnnotation && props.activeAnnotation.isInsertion) {\n            selectedElementId = idForInsertion(firstSelectedSegment);\n            segmentIdFunction = idForInsertion;\n          } else {\n            selectedElementId = idForSegment(firstSelectedSegment);\n            segmentIdFunction = idForSegment;\n          }\n        }\n      } else if (props.activeAnnotation) {\n        if (props.activeAnnotation.isDeletion) {\n          var _segment3 = new lib_TextSegment__WEBPACK_IMPORTED_MODULE_18__[\"default\"](startPos, \"\");\n\n          selectedElementId = idForDeletedSegment(_segment3);\n          segmentIdFunction = idForDeletedSegment;\n          firstSelectedSegment = _segment3;\n          selectedAnnotatedSegments = [firstSelectedSegment];\n        } else if (props.activeAnnotation.isInsertion) {\n          var _props$splitText$anno3 = props.splitText.annotatedText.getPositionOfAnnotation(props.activeAnnotation),\n              _props$splitText$anno4 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_props$splitText$anno3, 1),\n              start = _props$splitText$anno4[0];\n\n          if (start) {\n            var _segment4 = new lib_TextSegment__WEBPACK_IMPORTED_MODULE_18__[\"default\"](start, \"\");\n\n            selectedElementId = idForInsertion(_segment4);\n            segmentIdFunction = idForInsertion;\n            firstSelectedSegment = _segment4;\n            selectedAnnotatedSegments = [firstSelectedSegment];\n          }\n        } else if (props.activeAnnotation.type === ANNOTATION_TYPES.pageBreak) {\n          var _segment5 = new lib_TextSegment__WEBPACK_IMPORTED_MODULE_18__[\"default\"](startPos + 1, \"\");\n\n          var prevSegment = new lib_TextSegment__WEBPACK_IMPORTED_MODULE_18__[\"default\"](startPos, \"\");\n          selectedElementId = idForPageBreak(prevSegment);\n          firstSelectedSegment = _segment5;\n          selectedAnnotatedSegments = [_segment5];\n          selectedElementIds = [selectedElementId];\n        } else if (props.activeAnnotation.type === ANNOTATION_TYPES.lineBreak) {\n          var _segment6 = new lib_TextSegment__WEBPACK_IMPORTED_MODULE_18__[\"default\"](startPos + 1, \"\");\n\n          var _prevSegment = new lib_TextSegment__WEBPACK_IMPORTED_MODULE_18__[\"default\"](startPos, \"\");\n\n          selectedElementId = idForLineBreak(_prevSegment);\n          firstSelectedSegment = _segment6;\n          selectedAnnotatedSegments = [_segment6];\n          selectedElementIds = [selectedElementId];\n        }\n      }\n\n      if (segmentIdFunction) {\n        for (var _i2 = 0; _i2 < selectedAnnotatedSegments.length; _i2++) {\n          var _segment7 = selectedAnnotatedSegments[_i2];\n\n          if (_segment7 instanceof lib_TextSegment__WEBPACK_IMPORTED_MODULE_18__[\"default\"]) {\n            var _segmentId = segmentIdFunction(_segment7);\n\n            selectedElementIds.push(_segmentId);\n          }\n        }\n      }\n\n      if (selectedTextIndex != null && firstSelectedSegment && selectedElementId && splitTextRect) {\n        return {\n          selectedTextIndex: selectedTextIndex,\n          firstSelectedSegment: firstSelectedSegment,\n          selectedElementId: selectedElementId,\n          splitTextRect: splitTextRect,\n          selectedElementIds: selectedElementIds\n        };\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var props = this.props;\n      var rowRenderer = this.rowRenderer;\n      var cache = this.cache;\n      var key = props.selectedWitness ? props.selectedWitness.id : 0;\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8__.createElement(\"div\", {\n        className: (_SplitText_css__WEBPACK_IMPORTED_MODULE_16___default().splitText2),\n        ref: function ref(div) {\n          return _this5.splitText = div;\n        },\n        key: key,\n        style: {\n          cursor: \"pointer\"\n        }\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8__.createElement(\"button\", {\n        id: \"updateList2\",\n        style: {\n          display: \"none\"\n        },\n        onClick: function onClick() {\n          return _this5.updateList(true);\n        }\n      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8__.createElement(react_virtualized_dist_es_AutoSizer__WEBPACK_IMPORTED_MODULE_10__.AutoSizer, {\n        disableWidth: true\n      }, function (_ref) {\n        var height = _ref.height;\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8__.createElement(react_virtualized__WEBPACK_IMPORTED_MODULE_11__.List, {\n          ref: function ref(list) {\n            return _this5.list = list;\n          },\n          height: height,\n          rowCount: props.splitText.texts.length,\n          rowHeight: cache.rowHeight,\n          rowRenderer: rowRenderer,\n          width: 1,\n          overscanRowCount: 1,\n          deferredMeasurementCache: cache,\n          onScroll: _this5.scrollEvent,\n          scrollToAlignment: \"start\",\n          containerStyle: {\n            width: \"100%\",\n            maxWidth: \"100%\"\n          },\n          style: {\n            width: \"100%\"\n          }\n        });\n      }));\n    }\n  }, {\n    key: \"getStringPositions\",\n    value: function getStringPositions(text, string, index) {\n      var uniqueId = this.props.splitText.annotatedText.getUniqueId();\n\n      if (!_searchResultsCache.hasOwnProperty(uniqueId)) {\n        _searchResultsCache = (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, uniqueId, {});\n      }\n\n      if (!_searchResultsCache[uniqueId].hasOwnProperty(string)) {\n        _searchResultsCache[uniqueId] = (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, string, {});\n      }\n\n      if (_searchResultsCache[uniqueId][string].hasOwnProperty(index)) {\n        return _searchResultsCache[uniqueId][string][index];\n      }\n\n      var splitter = new (grapheme_splitter__WEBPACK_IMPORTED_MODULE_20___default())();\n      var content = text.getText();\n      var firstSegment = text.segments[0];\n      var startingPosition = firstSegment.start;\n      var positions = [];\n      var position = content.indexOf(string);\n\n      while (position !== -1) {\n        positions.push(position);\n        position = content.indexOf(string, position + 1);\n      } // Position needs to be position in complete text\n\n\n      var verifiedPositions = {};\n\n      if (positions.length > 0) {\n        var graphemes = splitter.splitGraphemes(content);\n        var _position2 = 0;\n        var activePosition = null;\n\n        for (var i = 0; i < graphemes.length; i++) {\n          var grapheme = graphemes[i];\n          var graphemeEnd = _position2 + (grapheme.length - 1);\n\n          if (activePosition !== null) {\n            var expectedEnd = activePosition + (string.length - 1);\n\n            if (graphemeEnd >= expectedEnd) {\n              verifiedPositions[activePosition + startingPosition] = [activePosition + startingPosition, graphemeEnd + startingPosition];\n              activePosition = null;\n            }\n          } else if (positions.indexOf(_position2) !== -1) {\n            if (string.length === grapheme.length) {\n              verifiedPositions[_position2 + startingPosition] = [_position2 + startingPosition, graphemeEnd + startingPosition];\n            } else if (string.length > grapheme.length) {\n              activePosition = _position2;\n            }\n          } else {\n            activePosition = null;\n          }\n\n          _position2 += grapheme.length;\n        }\n      }\n\n      _searchResultsCache[uniqueId][string][index] = verifiedPositions;\n      return verifiedPositions;\n    }\n  }, {\n    key: \"rowRenderer\",\n    value: function rowRenderer(_ref2) {\n      var key = _ref2.key,\n          index = _ref2.index,\n          parent = _ref2.parent,\n          style = _ref2.style;\n      var props = this.props;\n      var cache = this.cache;\n      var searchStringPositions = {};\n      var searchValue = this.props.searchValue;\n\n      if (searchValue && searchValue.length > 0 && props.splitText) {\n        searchStringPositions = this.getStringPositions(props.splitText.texts[index], searchValue, index);\n      }\n\n      var newStyle = _objectSpread(_objectSpread({}, style), {}, {\n        height: style.height + 10\n      });\n\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8__.createElement(react_virtualized_dist_es_CellMeasurer__WEBPACK_IMPORTED_MODULE_12__.CellMeasurer, {\n        columnIndex: 0,\n        key: key,\n        parent: parent,\n        rowIndex: index,\n        cache: cache\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8__.createElement(\"div\", {\n        key: key,\n        style: newStyle,\n        ref: this.splitTextRef,\n        id: \"index2_\".concat(index),\n        className: (_SplitText_css__WEBPACK_IMPORTED_MODULE_16___default().splitTextRow)\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8__.createElement(\"div\", {\n        className: (_SplitText_css__WEBPACK_IMPORTED_MODULE_16___default().splitTextRowContent)\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8__.createElement(_Text2__WEBPACK_IMPORTED_MODULE_14__[\"default\"], {\n        segmentedText: props.splitText.texts[index],\n        row: index,\n        selectedSegmentId: props.selectedSegmentId // searchValue={searchValue}\n        // selectedSearchResult={\n        //     this.props.selectedSearchResult\n        // }\n        ,\n        searchStringPositions: searchStringPositions,\n        textAlignmentById: props.textAlignmentById,\n        fontSize: props.fontSize,\n        isPanelLinked: this.props.isPanelLinked,\n        selectedSourceRange: props.selectedSourceRange,\n        selectedTargetRange: props.selectedTargetRange,\n        changeSelectedRange: props.changeSelectedRange,\n        changeSyncIdOnClick: this.props.changeSyncIdOnClick,\n        changeScrollToId: this.props.changeScrollToId,\n        condition: this.condition\n      }))));\n    }\n  }]);\n\n  return SplitTextComponent;\n}(react__WEBPACK_IMPORTED_MODULE_8__.PureComponent);\n\n\n\n//# sourceURL=webpack://teminusclient/./app/components/TextDetail2/SplitText.js?");

/***/ }),

/***/ "./app/components/TextDetail2/SplitText.css":
/*!**************************************************!*\
  !*** ./app/components/TextDetail2/SplitText.css ***!
  \**************************************************/
/***/ ((module) => {

eval("// extracted by mini-css-extract-plugin\nmodule.exports = {\"green-tint\":\"#88af8e\",\"blue-tint\":\"#024279\",\"active-button\":\"#00746b\",\"mainTint\":\"#024279\",\"activeButton\":\"#00746b\",\"inlineWidth\":\"280px\",\"annotationControls\":\"SplitText---annotationControls\",\"annotationContent\":\"SplitText---annotationContent\",\"subTitle\":\"SplitText---subTitle\",\"title\":\"SplitText---title\",\"sectionHeading\":\"SplitText---sectionHeading\",\"text\":\"SplitText---text\",\"padding\":\"SplitText---padding\",\"arrowTop\":\"SplitText---arrowTop\",\"arrowLeft\":\"SplitText---arrowLeft\",\"arrowRight\":\"SplitText---arrowRight\",\"inline\":\"SplitText---inline\",\"arrow\":\"SplitText---arrow\",\"arrowDs\":\"SplitText---arrowDs\",\"nothingSelected\":\"SplitText---nothingSelected\",\"anonymousMessage\":\"SplitText---anonymousMessage\",\"noNotes\":\"SplitText---noNotes\",\"breakButtons\":\"SplitText---breakButtons\",\"splitText2\":\"SplitText---splitText2\",\"splitTextRowContent\":\"SplitText---splitTextRowContent\",\"splitTextRow\":\"SplitText---splitTextRow\",\"pechaImage\":\"SplitText---pechaImage\",\"controlsPlaceholder\":\"SplitText---controlsPlaceholder\",\"pageNumber\":\"SplitText---pageNumber\"};\n\n//# sourceURL=webpack://teminusclient/./app/components/TextDetail2/SplitText.css?");

/***/ })

}]);